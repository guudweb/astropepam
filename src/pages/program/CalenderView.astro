---
import Layout from "../../layouts/Layout.astro";

const { isAdmin } = Astro.locals;
---

<Layout title="program">
  <div class="container mx-auto mt-8 text-center">
    <div class="flex justify-between mb-4 text-center mx-3">
      <button class="bg-cyan-600 text-white px-4 py-2 rounded" id="prevWeekBtn">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="icon icon-tabler icons-tabler-outline icon-tabler-chevrons-left"
          ><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path
            d="M11 7l-5 5l5 5"></path><path d="M17 7l-5 5l5 5"></path></svg
        >
      </button>
      <div class="text-center items-center flex justify-center gap-4">
        {
          isAdmin && (
            <a href="/program">
              <button
                class="bg-cyan-500 text-white px-3 py-2 rounded flex"
                id="CalenderViewBtn"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  class="icon icon-tabler icons-tabler-outline icon-tabler-chevron-left"
                >
                  <>
                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                    <path d="M15 6l-6 6l6 6" />
                  </>
                </svg>
                Editar
              </button>
            </a>
          )
        }
        <button
          onclick="saveTableAsPDF()"
          class="px-4 py-2 bg-blue-700 text-white font-bold rounded-md"
          title="PDF Estructurado"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="icon icon-tabler icons-tabler-outline icon-tabler-file-type-pdf"
          >
            <>
              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
              <path d="M14 3v4a1 1 0 0 0 1 1h4" />
              <path d="M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" />
              <path d="M5 18h1.5a1.5 1.5 0 0 0 0 -3h-1.5v6" />
              <path d="M17 18h2" />
              <path d="M20 15h-3v6" />
              <path d="M11 15v6h1a2 2 0 0 0 2 -2v-2a2 2 0 0 0 -2 -2h-1z" />
            </>
          </svg>
        </button>
        <button
          onclick="captureTableAsPDF()"
          class="px-4 py-2 bg-green-700 text-white font-bold rounded-md ml-2"
          title="PDF Vista Capturada"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="icon icon-tabler icons-tabler-outline icon-tabler-camera"
          >
            <>
              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
              <path d="M5 7h1a2 2 0 0 0 2 -2a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1a2 2 0 0 0 2 2h1a2 2 0 0 1 2 2v9a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-9a2 2 0 0 1 2 -2" />
              <path d="M9 13a3 3 0 1 0 6 0a3 3 0 0 0 -6 0" />
            </>
          </svg>
        </button>
      </div>
      <button class="bg-cyan-600 text-white px-4 py-2 rounded" id="nextWeekBtn">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="icon icon-tabler icons-tabler-outline icon-tabler-chevrons-right"
          ><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path
            d="M7 7l5 5l-5 5"></path><path d="M13 7l5 5l-5 5"></path></svg
        >
      </button>
    </div>
    <div
      id="calendarView"
      data-user-name={Astro.locals.user.name}
      class="overflow-x-auto"
    >
      <!-- The table will be dynamically generated by the script -->
    </div>
    <div
      id="phoneNumberPopup"
      class="hidden fixed bg-white border border-gray-200 p-2 rounded shadow-lg"
    >
    </div>
    <script is:inline>
      let currentDate = new Date(); // Define currentDate in the global scope
      let userNameMapping = {}; // Mapeo de userName a nombre completo

      const days = [
        "lunes",
        "martes",
        "miercoles",
        "jueves",
        "viernes",
        "sabado",
        "domingo",
      ];
      const turnos = ["T1", "T2", "T3", "T4"];
      const turnoTimes = {
        T1: "9:30 - 11:30",
        T2: "11:30 - 13:30",
        T3: "13:30 - 15:30",
        T4: "15:30 - 17:30",
      };

      // Función para obtener el mapeo de nombres
      const fetchUserNameMapping = async () => {
        try {
          const response = await fetch("/api/getUsersNameMapping.json");
          const data = await response.json();
          return data.mapping || {};
        } catch (error) {
          console.error("Error fetching user name mapping:", error);
          return {};
        }
      };

      // Función para obtener el nombre completo
      const getFullName = (userName) => {
        return userNameMapping[userName] || userName; // Fallback al userName si no se encuentra
      };

      const fetchWeekData = async (date) => {
        try {
          const response = await fetch(
            `/api/getWeekData.json?date=${date.toISOString().split("T")[0]}`
          );
          const data = await response.json();

          return data;
        } catch (error) {
          console.error("Error fetching week data:", error);
          return {};
        }
      };

      const fetchPhoneNumber = async (nombre) => {
        try {
          const response = await fetch(
            `/api/getUserPhoneNumber.json?nombre=${nombre}`
          );
          const data = await response.json();

          return data.telefono;
        } catch (error) {
          console.error("Error fetching phone number:", error);
          return "Phone number not available";
        }
      };

      // Cache para números de teléfono
      let phoneNumberCache = {};

      // Función para formatear números de teléfono
      const formatPhoneNumber = (phoneNumber) => {
        if (
          !phoneNumber ||
          phoneNumber === "Sin teléfono" ||
          phoneNumber === "Error" ||
          phoneNumber === "Phone number not available"
        ) {
          return phoneNumber;
        }

        // Primero, limpiar el string completo para tener solo dígitos
        const allDigits = phoneNumber.replace(/\D/g, "");

        // Si después de limpiar no hay dígitos, retornar "Sin teléfono"
        if (allDigits.length === 0) {
          return "Sin teléfono";
        }

        // Detectar si hay múltiples números concatenados
        let numbers = [];

        // Si hay separadores explícitos, usarlos
        if (/[,\/;|]/.test(phoneNumber)) {
          numbers = phoneNumber
            .split(/[,\/;|]+/)
            .filter((num) => num.trim().length > 0);
        } else {
          // Si no hay separadores, detectar números concatenados
          // Asumir que cada número tiene 9 dígitos (estándar español)
          if (allDigits.length >= 18 && allDigits.length % 9 === 0) {
            // Múltiples números de 9 dígitos
            for (let i = 0; i < allDigits.length; i += 9) {
              numbers.push(allDigits.slice(i, i + 9));
            }
          } else if (allDigits.length >= 16 && allDigits.length % 8 === 0) {
            // Múltiples números de 8 dígitos
            for (let i = 0; i < allDigits.length; i += 8) {
              numbers.push(allDigits.slice(i, i + 8));
            }
          } else if (allDigits.length >= 18) {
            // Intentar dividir en números de 9 dígitos
            for (let i = 0; i < allDigits.length; i += 9) {
              if (i + 9 <= allDigits.length) {
                numbers.push(allDigits.slice(i, i + 9));
              } else {
                // El último número puede tener menos dígitos
                numbers.push(allDigits.slice(i));
              }
            }
          } else {
            // Un solo número
            numbers = [phoneNumber];
          }
        }

        const formatSingleNumber = (num) => {
          // Limpiar el número: solo dígitos
          const cleanNum = num.replace(/\D/g, "");

          // Si tiene 9 dígitos (formato español estándar)
          if (cleanNum.length === 9) {
            return `${cleanNum.slice(0, 3)} ${cleanNum.slice(3, 5)} ${cleanNum.slice(5, 7)} ${cleanNum.slice(7, 9)}`;
          }

          // Si tiene más o menos dígitos, intentar formatear igualmente
          if (cleanNum.length >= 6) {
            if (cleanNum.length === 8) {
              return `${cleanNum.slice(0, 2)} ${cleanNum.slice(2, 4)} ${cleanNum.slice(4, 6)} ${cleanNum.slice(6, 8)}`;
            } else if (cleanNum.length === 7) {
              return `${cleanNum.slice(0, 3)} ${cleanNum.slice(3, 5)} ${cleanNum.slice(5, 7)}`;
            } else {
              // Para números más largos, aplicar formato básico
              return `${cleanNum.slice(0, 3)} ${cleanNum.slice(3, 5)} ${cleanNum.slice(5, 7)} ${cleanNum.slice(7)}`;
            }
          }

          // Si es muy corto, devolverlo sin formatear
          return cleanNum;
        };

        // Formatear cada número y unirlos con " / "
        const formattedNumbers = numbers.map(formatSingleNumber);
        return formattedNumbers.join(" / ");
      };

      const getPhoneNumber = async (userName) => {
        if (!userName) return "";

        if (phoneNumberCache[userName]) {
          return phoneNumberCache[userName];
        }

        try {
          const phone = await fetchPhoneNumber(userName);
          console.log(`Phone for ${userName}:`, phone); // Debug log
          const formattedPhone = formatPhoneNumber(phone);
          console.log(`Formatted phone for ${userName}:`, formattedPhone); // Debug log
          phoneNumberCache[userName] = formattedPhone || "";
          return phoneNumberCache[userName];
        } catch (error) {
          console.error("Error getting phone number:", error);
          return "";
        }
      };

      const showPhoneNumber = (phoneNumber, event) => {
        const popup = document.getElementById("phoneNumberPopup");
        popup.innerText = phoneNumber;
        popup.style.top = `${event.clientY}px`;
        popup.style.left = `${event.clientX}px`;
        popup.classList.remove("hidden");
      };

      const hidePhoneNumber = () => {
        const popup = document.getElementById("phoneNumberPopup");
        popup.classList.add("hidden");
      };

      const updateWeek = async () => {
        // Cargar el mapeo de nombres si no lo tenemos
        if (Object.keys(userNameMapping).length === 0) {
          userNameMapping = await fetchUserNameMapping();
        }

        const weekDates = getWeekDates(currentDate);
        const weekData = await fetchWeekData(currentDate);

        const calendarView = document.getElementById("calendarView");
        const user = calendarView.dataset.userName || "";
        calendarView.innerHTML = `
  <div class="hidden md:block">
    <table id="desktopTable" class="min-w-full bg-white border border-gray-200 mb-4">
      <thead>
        <tr>
          <th class="px-4 py-2 border-b text-center">Turno</th>
          ${weekDates
            .map((date, index) => {
              if (days[index] !== "lunes") {
                return `<th class="px-4 py-2 border-b text-center">${formatDate(date, days[index])}</th>`;
              }
              return "";
            })
            .join("")}
        </tr>
      </thead>
      <tbody>
        ${turnos
          .map(
            (turno, turnoIndex) => `
          <tr class="${turnoIndex % 2 === 0 ? "bg-gray-100" : "bg-white"}">
            <td class="px-4 py-2 border-b">${turnoTimes[turno]}</td>
            ${days
              .map((day, dayIndex) => {
                if (day !== "lunes") {
                  const date = weekDates[dayIndex];
                  return `
                    <td class="px-4 py-2 border-b" data-day="${day}">
                      ${Array.from({ length: 4 })
                        .map((_, index) => {
                          const userName =
                            weekData[`${day}-${turno}-${index}`] || "";
                          const fullName = getFullName(userName);
                          const isCurrentUser = userName === user;
                          const isFirstInShift = index === 0;

                          if (!userName) {
                            // Solo mostrar "Turno disponible" para las primeras 3 posiciones
                            if (index < 3) {
                              return '<div class="empty-slot" style="margin-bottom: 8px; padding: 8px; background-color: #fee2e2; color: #991b1b; text-align: center; border-radius: 4px; display: flex; align-items: center; justify-content: center;">Turno disponible</div>';
                            } else {
                              return ""; // No mostrar nada para la 4ta posición vacía
                            }
                          }

                          return `<div class="user" data-nombre="${userName}" style="margin-bottom: 8px;${
                            isCurrentUser
                              ? "color: blue; font-weight: bold;"
                              : isFirstInShift
                                ? "font-weight: bold; color: #1e3a8a;"
                                : ""
                          }">
                            <div>${fullName}</div>
                            <div class="phone-number" style="font-size: 0.8em; color: #666; margin-top: 2px;" data-user="${userName}">Cargando...</div>
                          </div>`;
                        })
                        .join("")}
                    </td>
                  `;
                }
                return "";
              })
              .join("")}
          </tr>
        `
          )
          .join("")}
      </tbody>
    </table>
  </div>
  <div class="md:hidden">
    ${days
      .map((day, dayIndex) => {
        if (day !== "lunes") {
          const date = weekDates[dayIndex];
          return `
            <div class="mb-4">
              <h2 class="text-lg font-bold mb-2">${day.charAt(0).toUpperCase() + day.slice(1)}</h2>
              <table class="min-w-full bg-white border border-gray-200 mb-4">
                <thead>
                  <tr>
                    <th class="px-4 py-2 border-b text-center">Turno</th>
                    <th class="px-4 py-2 border-b text-center">${formatDate(date, day)}</th>
                  </tr>
                </thead>
                <tbody>
                  ${turnos
                    .map(
                      (turno, turnoIndex) => `
                    <tr class="${turnoIndex % 2 === 0 ? "bg-gray-100" : "bg-white"}">
                      <td class="px-4 py-2 border-b">${turnoTimes[turno]}</td>
                      <td class="px-4 py-2 border-b">
                        ${Array.from({ length: 4 })
                          .map((_, index) => {
                            const userName =
                              weekData[`${day}-${turno}-${index}`] || "";
                            const fullName = getFullName(userName);
                            const isCurrentUser = userName === user;
                            const isFirstInShift = index === 0;

                            if (!userName) {
                              // Solo mostrar "Turno disponible" para las primeras 3 posiciones
                              if (index < 3) {
                                return '<div class="empty-slot" style="margin-bottom: 8px; padding: 8px; background-color: #fee2e2; color: #991b1b; text-align: center; border-radius: 4px; display: flex; align-items: center; justify-content: center;">Turno disponible</div>';
                              } else {
                                return ""; // No mostrar nada para la 4ta posición vacía
                              }
                            }

                            return `<div class="user" data-nombre="${userName}" style="margin-bottom: 8px; ${
                              isCurrentUser
                                ? "color: blue; font-weight: bold;"
                                : isFirstInShift
                                  ? "font-weight: bold; color: #1e3a8a;"
                                  : ""
                            }">
                              <div>${fullName}</div>
                              <div class="phone-number" style="font-size: 0.8em; color: #666; margin-top: 2px;" data-user="${userName}">Cargando...</div>
                            </div>`;
                          })
                          .join("")}
                      </td>
                    </tr>
                  `
                    )
                    .join("")}
                </tbody>
              </table>
            </div>
          `;
        }
        return "";
      })
      .join("")}
  </div>
`;

        // Cargar números de teléfono para todos los usuarios visibles
        const phoneNumberElements = document.querySelectorAll(".phone-number");
        phoneNumberElements.forEach(async (phoneElement) => {
          const userName = phoneElement.dataset.user;
          if (userName) {
            try {
              const phoneNumber = await getPhoneNumber(userName);
              // Verificar si realmente hay un número o si está vacío/sin teléfono
              if (
                phoneNumber &&
                phoneNumber !== "Phone number not available" &&
                phoneNumber !== "Sin teléfono" &&
                phoneNumber !== "Error"
              ) {
                phoneElement.textContent = phoneNumber;
              } else {
                phoneElement.textContent = "Sin teléfono";
              }
            } catch (error) {
              phoneElement.textContent = "Error";
            }
          }
        });

        document.querySelectorAll(".user").forEach((user) => {
          const userElement = user;
          userElement.addEventListener("click", async (event) => {
            const userName = userElement.dataset.nombre; // Este es el userName guardado

            const phoneNumber = await fetchPhoneNumber(userName);
            showPhoneNumber(phoneNumber, event);
          });
        });

        document.addEventListener("click", (event) => {
          const target = event.target;
          if (!target.classList.contains("user")) {
            hidePhoneNumber();
          }
        });
      };

      const getWeekDates = (currentDate) => {
        const startOfWeek = new Date(currentDate);
        startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay() + 1);
        const dates = [];
        for (let i = 0; i < 7; i++) {
          const date = new Date(startOfWeek);
          date.setDate(startOfWeek.getDate() + i);
          dates.push(date);
        }
        return dates;
      };

      const formatDate = (date, dayName) => {
        const day = date.getDate();
        return `${dayName.charAt(0).toUpperCase() + dayName.slice(1)} ${day}`;
      };

      document.addEventListener("DOMContentLoaded", () => {
        const prevWeekBtn = document.getElementById("prevWeekBtn");
        const nextWeekBtn = document.getElementById("nextWeekBtn");

        prevWeekBtn.addEventListener("click", () => {
          currentDate.setDate(currentDate.getDate() - 7);
          updateWeek();
        });
        nextWeekBtn.addEventListener("click", () => {
          currentDate.setDate(currentDate.getDate() + 7);
          updateWeek();
        });

        // Initial load
        updateWeek();
      });

      const saveTableAsPDF = async () => {
        const { jsPDF } = window.jspdf;

        const doc = new jsPDF({
          orientation: "landscape",
          unit: "px",
          format: "a4",
        });

        // Obtener datos de la semana actual
        const weekDates = getWeekDates(currentDate);
        const weekData = await fetchWeekData(currentDate);

        const pageWidth = doc.internal.pageSize.getWidth();
        const margin = 15;
        let yPosition = 20;

        // Título del documento
        doc.setFontSize(16);
        doc.setFont(undefined, "bold");
        // Get start date BEFORE using it
        const startDate = weekDates[1]; // Martes (índice 1)
        const endDate = weekDates[6]; // Domingo (índice 6)
        const monthName = startDate.toLocaleDateString("es-ES", {
          month: "long",
        });
        const year = startDate.getFullYear();
        const capitalizedMonth =
          monthName.charAt(0).toUpperCase() + monthName.slice(1);
        doc.text(
          `PPAM Programa Semanal - ${capitalizedMonth} ${year}`,
          pageWidth / 2,
          yPosition,
          {
            align: "center",
          }
        );
        yPosition += 25;

        // Fechas de la semana
        doc.setFontSize(10);
        doc.setFont(undefined, "normal");
        doc.text(
          `${startDate.toLocaleDateString("es-ES")} - ${endDate.toLocaleDateString("es-ES")}`,
          pageWidth / 2,
          yPosition,
          { align: "center" }
        );
        yPosition += 20;

        // Crear encabezados de la tabla (igual que la página calendario)
        const headers = ["Turno"];
        const visibleDays = [];

        // Agregar días como columnas (excluyendo lunes)
        for (let dayIndex = 1; dayIndex < days.length; dayIndex++) {
          const day = days[dayIndex];
          const date = weekDates[dayIndex];
          visibleDays.push({ day, date, index: dayIndex });
          headers.push(
            `${day.charAt(0).toUpperCase() + day.slice(1)} ${date.getDate()}`
          );
        }

        // Crear filas de datos
        const tableData = [];
        turnos.forEach((turno) => {
          const row = [turnoTimes[turno]]; // Primera columna: horario del turno

          // Agregar datos para cada día
          visibleDays.forEach(({ day }) => {
            const usuarios = [];

            for (let index = 0; index < 4; index++) {
              const userName = weekData[`${day}-${turno}-${index}`] || "";

              if (!userName) {
                // Solo agregar "Turno disponible" para las primeras 3 posiciones
                if (index < 3) {
                  usuarios.push("Turno disponible");
                }
                continue;
              }

              const fullName = getFullName(userName);
              const isFirstInShift = index === 0;

              let displayText = fullName;
              if (isFirstInShift) {
                displayText = `★ ${fullName}`; // Marcar primer nombre con estrella
              }

              // Agregar número de teléfono si está disponible
              const phoneNumber = phoneNumberCache[userName];
              if (
                phoneNumber &&
                phoneNumber !== "Sin teléfono" &&
                phoneNumber !== "Error"
              ) {
                displayText += `\n${phoneNumber}`;
              }

              usuarios.push(displayText);
            }

            row.push(usuarios.join("\n\n"));
          });

          tableData.push(row);
        });

        // Calcular ancho de columnas
        const totalColumns = headers.length;
        const turnoColumnWidth = 80;
        const dayColumnWidth =
          (pageWidth - margin * 2 - turnoColumnWidth) / (totalColumns - 1);

        // Configurar estilos de columnas
        const columnStyles = {
          0: {
            cellWidth: turnoColumnWidth,
            halign: "center",
            valign: "middle",
          },
        };

        for (let i = 1; i < totalColumns; i++) {
          columnStyles[i] = {
            cellWidth: dayColumnWidth,
            halign: "center",
            valign: "top",
            fontSize: 7,
          };
        }

        // Generar la tabla
        doc.autoTable({
          head: [headers],
          body: tableData,
          startY: yPosition,
          margin: { left: margin, right: margin },
          theme: "grid",
          styles: {
            fontSize: 7,
            cellPadding: 4,
            valign: "top",
            lineWidth: 0.1,
            lineColor: [0, 0, 0],
            overflow: "linebreak",
          },
          headStyles: {
            fillColor: [59, 130, 246], // bg-blue-600
            textColor: [255, 255, 255],
            fontStyle: "bold",
            fontSize: 8,
            halign: "center",
            valign: "middle",
          },
          columnStyles: columnStyles,
          alternateRowStyles: {
            fillColor: [243, 244, 246], // bg-gray-100
          },
          didParseCell: function (data) {
            // Get cell text - handle both string and array formats
            let cellText = "";
            
            if (data.cell.text) {
              if (typeof data.cell.text === "string") {
                cellText = data.cell.text;
              } else if (Array.isArray(data.cell.text)) {
                cellText = data.cell.text.join(" ");
              }
            }
            
            if (!cellText && data.cell.raw) {
              cellText = String(data.cell.raw);
            }

            console.log("Processing cell:", cellText);

            // Check for "Turno disponible" ONLY if it's the entire content
            if (cellText && cellText.trim() === "Turno disponible") {
              console.log('Found ONLY "Turno disponible" - applying RED and BOLD');
              // Apply styles directly without Object.assign
              data.cell.styles.fillColor = [220, 38, 38];
              data.cell.styles.textColor = [255, 255, 255];
              data.cell.styles.fontStyle = 'bold';
              data.cell.styles.halign = 'center';
              data.cell.styles.valign = 'middle';
              data.cell.styles.fontSize = 8;
              return;
            }

            // Check for first volunteer (★) - second priority
            if (cellText && cellText.includes("★")) {
              console.log('Found first volunteer (★) - applying BLUE and BOLD');
              
              // Remove the star from display
              if (Array.isArray(data.cell.text)) {
                data.cell.text = data.cell.text.map((line) =>
                  line.replace(/★/g, "").trim()
                );
              } else if (typeof data.cell.text === "string") {
                data.cell.text = data.cell.text.replace(/★/g, "").trim();
              }
              
              // Apply blue bold styling directly
              data.cell.styles.textColor = [29, 78, 216];
              data.cell.styles.fontStyle = 'bold';
              data.cell.styles.halign = 'center';
              data.cell.styles.valign = 'top';
              data.cell.styles.fontSize = 7;
              return;
            }

            // Default styling for regular volunteers
            if (cellText && data.column.index > 0) {
              data.cell.styles.halign = 'center';
              data.cell.styles.valign = 'top';
              data.cell.styles.fontSize = 7;
            }
          },
          willDrawCell: function (data) {
            // willDrawCell se ejecuta justo antes de dibujar, garantizando que los estilos se apliquen
            if (data.cell.raw) {
              const cellText = String(data.cell.raw);
              if (cellText.includes("Turno disponible")) {
                // Forzar el centrado justo antes de dibujar
                data.cell.styles.halign = "center";
                data.cell.styles.valign = "middle";
                data.cell.styles.fillColor = [254, 226, 226];
                data.cell.styles.textColor = [153, 27, 27];
              }
            }
          },
        });

        // Descargar el PDF
        doc.save("calendario-programa.pdf");
      };

      // Nueva función para capturar la tabla directamente con html2canvas
      const captureTableAsPDF = async () => {
        try {
          const { jsPDF } = window.jspdf;

          // Seleccionar el elemento de la tabla a capturar
          const tableElement = document.getElementById("calendarView");

          if (!tableElement) {
            alert("No se encontró la tabla del calendario");
            return;
          }

          // Pequeño delay para asegurar que todos los estilos están aplicados
          await new Promise((resolve) => setTimeout(resolve, 100));

          // Configurar html2canvas para mejor calidad
          const canvas = await html2canvas(tableElement, {
            scale: 2, // Mayor resolución
            useCORS: true, // Permitir recursos externos
            allowTaint: false,
            backgroundColor: "#ffffff",
            scrollX: 0,
            scrollY: 0,
            width: tableElement.scrollWidth,
            height: tableElement.scrollHeight,
            removeContainer: true,
            logging: false,
            onclone: (clonedDoc) => {
              // Asegurar que el elemento clonado sea visible
              const clonedElement = clonedDoc.getElementById("calendarView");
              if (clonedElement) {
                clonedElement.style.display = "block";
                clonedElement.style.visibility = "visible";

                // Forzar que se muestre la vista de escritorio en el clon
                const desktopView =
                  clonedElement.querySelector(".hidden.md\\:block");
                if (desktopView) {
                  desktopView.classList.remove("hidden");
                  desktopView.classList.add("block");
                }

                // Ocultar vista móvil en el clon
                const mobileView = clonedElement.querySelector(".md\\:hidden");
                if (mobileView) {
                  mobileView.style.display = "none";
                }

                // Asegurar que los estilos de centrado se apliquen correctamente
                const headers = clonedElement.querySelectorAll("th");
                headers.forEach((header) => {
                  header.style.textAlign = "center";
                  header.classList.add("text-center");
                });

                // Asegurar que "Turno disponible" esté centrado
                const emptySlots =
                  clonedElement.querySelectorAll(".empty-slot");
                emptySlots.forEach((slot) => {
                  slot.style.textAlign = "center";
                  slot.style.display = "flex";
                  slot.style.alignItems = "center";
                  slot.style.justifyContent = "center";
                  slot.style.width = "100%";
                  slot.style.height = "100%";
                });

                // Añadir estilos CSS directamente al documento clonado
                const style = clonedDoc.createElement("style");
                style.textContent = `
                  th { text-align: center !important; }
                  .empty-slot { 
                    text-align: center !important; 
                    display: flex !important; 
                    align-items: center !important; 
                    justify-content: center !important; 
                    width: 100% !important;
                    height: 100% !important;
                  }
                `;
                clonedDoc.head.appendChild(style);

                // Forzar recálculo de estilos
                clonedElement.style.transform = "translateZ(0)";
                clonedElement.offsetHeight; // Trigger reflow
              }
            },
          });

          // Crear el PDF
          const imgWidth = 297; // A4 landscape width in mm
          const imgHeight = (canvas.height * imgWidth) / canvas.width;

          const doc = new jsPDF({
            orientation: "landscape",
            unit: "mm",
            format: "a4",
          });

          // Agregar título y fecha
          doc.setFontSize(16);
          doc.setFont(undefined, "bold");
          const weekDatesForTitle = getWeekDates(currentDate);
          const startDateForTitle = weekDatesForTitle[1]; // Martes
          const monthNameCapture = startDateForTitle.toLocaleDateString(
            "es-ES",
            { month: "long" }
          );
          const yearCapture = startDateForTitle.getFullYear();
          const capitalizedMonthCapture =
            monthNameCapture.charAt(0).toUpperCase() +
            monthNameCapture.slice(1);
          doc.text(
            `PPAM Programa Semanal - ${capitalizedMonthCapture} ${yearCapture}`,
            doc.internal.pageSize.getWidth() / 2,
            15,
            { align: "center" }
          );

          doc.setFontSize(10);
          doc.setFont(undefined, "normal");

          // Agregar la imagen capturada
          const imgData = canvas.toDataURL("image/jpeg", 0.95);

          // Calcular posición para centrar la imagen
          const pageWidth = doc.internal.pageSize.getWidth();
          const pageHeight = doc.internal.pageSize.getHeight();
          const startY = 30;
          const availableHeight = pageHeight - startY - 10;

          let finalWidth = imgWidth;
          let finalHeight = imgHeight;

          // Ajustar tamaño si es muy alto
          if (finalHeight > availableHeight) {
            finalHeight = availableHeight;
            finalWidth = (canvas.width * finalHeight) / canvas.height;
          }

          // Centrar horizontalmente
          const startX = (pageWidth - finalWidth) / 2;

          doc.addImage(
            imgData,
            "JPEG",
            startX,
            startY,
            finalWidth,
            finalHeight
          );

          // Descargar el PDF
          doc.save("calendario-capturado.pdf");
        } catch (error) {
          console.error("Error capturando la tabla:", error);
          alert("Error al generar el PDF. Por favor, inténtalo de nuevo.");
        }
      };
    </script>
  </div>
</Layout>

<script
  is:inline
  src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.2/html2pdf.bundle.min.js"
></script>

<script
  is:inline
  src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js"
></script>
<script
  is:inline
  src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.13/jspdf.plugin.autotable.min.js"
></script>
<script
  is:inline
  src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
></script>

<!-- <script is:inline>
  const saveDivAsPDF = () => {
    const element = document.querySelector(".md\\:block"); // Select the desktop view
    element.classList.add("pdf-content"); // Add the CSS class to the element

    const opt = {
      margin: [20, 10, 0, 10], // Add margins (top, right, bottom, left)
      filename: "calendar.pdf",
      image: { type: "jpeg", quality: 1.0 }, // Increase the quality
      html2canvas: { scale: 2 }, // Adjust the scale to increase quality
      jsPDF: { unit: "px", format: [1366, 546], orientation: "landscape" },
    };

    // Use html2pdf to generate the PDF
    html2pdf().from(element).set(opt).save();
  };
</script>

<style>
  .pdf-content {
    border: 2px solid black; /* Adjust the border size and color as needed */
    padding: 10px; /* Add padding to create space between the content and the border */
    text-align: center; /* Center the text */
  }
</style> -->
