---
import Layout from "../../layouts/Layout.astro";
import WeekNavigation from "../../components/Program/WeekNavigation.astro";
import ResponsiveScheduleView from "../../components/Program/ResponsiveScheduleView.astro";
import { DAYS } from "../../constants/days";
import { TURNS } from "../../constants/turns";

// Extraer solo los valores de los dÃ­as para compatibilidad
const days = DAYS.filter(d => d.value).map(d => d.value);
const turnos = TURNS.filter(t => t.value).map(t => t.value);

// Obtener fecha de URL o usar fecha actual
const url = Astro.url;
const dateParam = url.searchParams.get('date');
let currentDate = new Date();

if (dateParam) {
  const parsedDate = new Date(dateParam);
  if (!isNaN(parsedDate.getTime())) {
    currentDate = parsedDate;
  }
}

// Obtener fechas de la semana actual
const getWeekDates = (date: Date) => {
  const startOfWeek = new Date(date);
  const day = startOfWeek.getDay();
  const diff = startOfWeek.getDate() - day + (day === 0 ? -6 : 1);
  startOfWeek.setDate(diff);
  
  const dates = [];
  for (let i = 0; i < 7; i++) {
    const weekDate = new Date(startOfWeek);
    weekDate.setDate(startOfWeek.getDate() + i);
    dates.push(weekDate);
  }
  return dates;
};

const weekDates = getWeekDates(currentDate);
---

<Layout title="program">
  <div id="spinnerOverlay" class="spinner-overlay">
    <div class="spinner"></div>
  </div>
  <div class="container mx-auto mt-4 px-2 lg:px-4">
    <!-- Nueva navegaciÃ³n responsive -->
    <WeekNavigation currentDate={currentDate} />

    <!-- Barra de bÃºsqueda en vista principal -->
    <div class="mb-4 relative">
      <div class="flex items-center gap-2 bg-white border-2 border-gray-200 rounded-lg px-4 py-2 focus-within:border-blue-500 transition-colors">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
        </svg>
        <input
          type="text"
          id="programSearchInput"
          class="flex-1 outline-none text-base placeholder-gray-400"
          placeholder="Buscar usuario en el programa..."
        />
        <button
          id="clearSearchBtn"
          class="text-gray-400 hover:text-gray-600 hidden"
          title="Limpiar bÃºsqueda"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      <div id="searchResultsInfo" class="absolute right-4 top-full mt-1 text-sm text-gray-500 hidden"></div>
    </div>

    <!-- Barra de herramientas mobile-friendly -->
    <div class="flex flex-col sm:flex-row gap-3 mb-6 items-stretch sm:items-center sm:justify-center">
      <!-- Preajustes dropdown - Mobile first -->
      <div class="flex-1 sm:flex-none">
        <select
          id="preajustesSelect"
          class="w-full sm:w-auto px-4 py-3 border-2 border-gray-300 rounded-lg text-base focus:ring-2 focus:ring-blue-500 focus:border-blue-500 touch-manipulation"
        >
          <option value="" selected>PreAjustes</option>
          <option value="cargar">Cargar Preajuste</option>
          <option value="guardar">Guardar Preajuste</option>
        </select>
      </div>

      <!-- BotÃ³n Copiar Semana Anterior -->
      <button
        id="copyPreviousWeekBtn"
        class="p-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 active:bg-purple-800 transition-colors duration-200 touch-manipulation"
        title="Copiar semana anterior"
      >
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>
      </button>

      <!-- Botones de Undo/Redo -->
      <div class="flex gap-2">
        <button
          id="undoBtn"
          class="p-3 bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300 active:bg-gray-400 transition-colors duration-200 touch-manipulation disabled:opacity-50 disabled:cursor-not-allowed"
          title="Deshacer (Ctrl+Z)"
          disabled
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 7v6h6"></path>
            <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path>
          </svg>
        </button>
        <button
          id="redoBtn"
          class="p-3 bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300 active:bg-gray-400 transition-colors duration-200 touch-manipulation disabled:opacity-50 disabled:cursor-not-allowed"
          title="Rehacer (Ctrl+Y)"
          disabled
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 7v6h-6"></path>
            <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"></path>
          </svg>
        </button>
      </div>

      <!-- BotÃ³n Verificar Capitanes -->
      <button
        id="validateCapitanesBtn"
        class="p-3 bg-amber-600 text-white rounded-lg hover:bg-amber-700 active:bg-amber-800 transition-colors duration-200 touch-manipulation"
        title="Verificar capitanes por turno"
      >
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
          <path d="M2 17l10 5 10-5"></path>
          <path d="M2 12l10 5 10-5"></path>
        </svg>
      </button>

      <!-- Botones de acciÃ³n -->
      <div class="flex gap-3">
        <button
          class="flex-1 sm:flex-none flex items-center justify-center gap-2 bg-blue-700 text-white px-6 py-3 rounded-lg hover:bg-blue-800 active:bg-blue-900 transition-colors duration-200 touch-manipulation"
          id="saveBtn"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2"></path>
            <path d="M12 14m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0"></path>
            <path d="M14 4l0 4l-6 0l0 -4"></path>
          </svg>
          <span class="hidden sm:inline">Guardar</span>
        </button>

        <a href="/program/CalenderView" class="flex-1 sm:flex-none">
          <button class="w-full flex items-center justify-center gap-2 bg-cyan-600 text-white px-6 py-3 rounded-lg hover:bg-cyan-700 active:bg-cyan-800 transition-colors duration-200 touch-manipulation">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
              <line x1="16" y1="2" x2="16" y2="6"></line>
              <line x1="8" y1="2" x2="8" y2="6"></line>
              <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
            <span class="hidden sm:inline">Calendario</span>
          </button>
        </a>

        <a href="/user-history" class="flex-1 sm:flex-none">
          <button class="w-full flex items-center justify-center gap-2 bg-teal-600 text-white px-6 py-3 rounded-lg hover:bg-teal-700 active:bg-teal-800 transition-colors duration-200 touch-manipulation">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M12 8l0 4l2 2"></path>
              <path d="M3.05 11a9 9 0 1 1 .5 4m-.5 5v-5h5"></path>
            </svg>
            <span class="hidden sm:inline">Historial</span>
          </button>
        </a>
      </div>
    </div>

    <!-- Vista unificada responsiva del programa -->
    <div id="currentView">
      <ResponsiveScheduleView 
        days={days}
        turnos={turnos}
        weekDates={weekDates}
      />
    </div>
    <!-- Modal Responsive -->
    <div
      id="userModal"
      class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center hidden p-4 z-50"
    >
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[90vh] flex flex-col">
        <!-- Header -->
        <div class="flex items-center justify-between p-6 border-b border-gray-200">
          <h2 class="text-xl font-semibold text-gray-900">Seleccionar Usuario</h2>
          <button
            id="closeModalBtn"
            class="text-gray-400 hover:text-gray-600 transition-colors p-2"
            aria-label="Cerrar modal"
          >
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>

        <!-- Search -->
        <div class="p-6 border-b border-gray-200">
          <input
            type="text"
            id="userSearch"
            class="w-full px-4 py-3 border border-gray-300 rounded-lg text-base focus:ring-2 focus:ring-blue-500 focus:border-blue-500 touch-manipulation"
            placeholder="Buscar usuario..."
          />
        </div>

        <!-- Lista de usuarios -->
        <div class="flex-1 overflow-y-auto p-6">
          <ul id="userList" class="space-y-2">
            <li class="text-center py-8 text-gray-500">
              <svg class="w-12 h-12 mx-auto mb-3 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
              </svg>
              Cargando usuarios...
            </li>
          </ul>
        </div>

        <!-- Footer -->
        <div class="p-6 border-t border-gray-200">
          <button
            class="w-full bg-gray-500 text-white py-3 px-4 rounded-lg hover:bg-gray-600 active:bg-gray-700 transition-colors duration-200 touch-manipulation"
            id="closeModalBtnFooter"
          >
            Cancelar
          </button>
        </div>
      </div>
    </div>

    <!-- Modal de confirmaciÃ³n -->
    <div
      id="confirmationModal"
      class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden"
    >
      <div class="bg-white p-8 rounded mx-6 shadow-lg">
        <h2 class="text-xl mb-4">Â¿Guardar cambios?</h2>
        <p class="mb-4">Â¿Quieres guardar los cambios antes de continuar?</p>
        <div class="flex justify-end">
          <button
            id="cancelBtn"
            class="bg-red-500 text-white px-4 py-2 rounded mr-2"
          >
            No
          </button>
          <button
            id="saveBtnModal"
            class="bg-blue-500 text-white px-4 py-2 rounded"
          >
            SÃ­
          </button>
        </div>
      </div>
    </div>

    <!-- Popup de advertencia -->
    <div
      id="warningPopup"
      class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden"
    >
      <div class="bg-white p-4 rounded shadow-lg">
        <h2 class="text-xl mb-4">Advertencia</h2>
        <p id="warningMessage"></p>
        <button
          class="mt-4 bg-red-500 text-white px-4 py-2 rounded"
          id="closeWarningBtn"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Panel de Notificaciones -->
    <div
      id="notificationsPanel"
      class="fixed top-4 right-4 w-96 bg-white rounded-lg shadow-xl border z-50 hidden"
    >
      <div class="flex items-center justify-between p-4 border-b bg-gray-50 rounded-t-lg">
        <h3 class="text-lg font-semibold text-gray-800 flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-5 5-5-5h5V3h0z" />
          </svg>
          Notificaciones
          <span id="notificationCount" class="ml-2 bg-blue-600 text-white text-xs px-2 py-1 rounded-full">0</span>
        </h3>
        <button
          id="closeNotificationsBtn"
          class="text-gray-500 hover:text-gray-700 p-1"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      <div class="max-h-96 overflow-y-auto">
        <div id="notificationsList" class="p-4">
          <div class="text-center text-gray-500 py-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-3 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-5 5-5-5h5V3h0z" />
            </svg>
            <p>No hay notificaciones</p>
          </div>
        </div>
      </div>
      <div class="p-3 border-t bg-gray-50 rounded-b-lg">
        <button
          id="clearNotificationsBtn"
          class="w-full bg-gray-600 text-white py-2 px-4 rounded hover:bg-gray-700 transition-colors text-sm"
        >
          Limpiar todas
        </button>
      </div>
    </div>

    <!-- BotÃ³n flotante para abrir panel -->
    <button
      id="notificationsToggle"
      class="fixed bottom-6 right-6 bg-blue-600 text-white p-3 rounded-full shadow-lg hover:bg-blue-700 transition-colors z-40"
      title="Ver notificaciones"
    >
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-5 5-5-5h5V3h0z" />
      </svg>
      <span id="floatingNotificationBadge" class="absolute -top-2 -right-2 bg-red-500 text-white text-xs w-6 h-6 rounded-full flex items-center justify-center hidden">0</span>
    </button>

    <!-- Panel de Conflictos Global -->
    <div
      id="conflictsPanel"
      class="fixed top-4 left-4 w-96 bg-white rounded-lg shadow-xl border z-50 hidden max-h-[80vh] flex flex-col"
    >
      <div class="flex items-center justify-between p-4 border-b bg-red-50 rounded-t-lg">
        <h3 class="text-lg font-semibold text-red-800 flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
          Conflictos de la Semana
          <span id="conflictsCount" class="ml-2 bg-red-600 text-white text-xs px-2 py-1 rounded-full">0</span>
        </h3>
        <button
          id="closeConflictsBtn"
          class="text-gray-500 hover:text-gray-700 p-1"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      <div class="flex-1 overflow-y-auto p-4">
        <div id="conflictsList">
          <div class="text-center text-gray-500 py-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-3 text-green-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <p>No hay conflictos detectados</p>
          </div>
        </div>
      </div>
      <div class="p-3 border-t bg-gray-50 rounded-b-lg">
        <button
          id="refreshConflictsBtn"
          class="w-full bg-red-600 text-white py-2 px-4 rounded hover:bg-red-700 transition-colors text-sm flex items-center justify-center gap-2"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
          Analizar Conflictos
        </button>
      </div>
    </div>

    <!-- BotÃ³n flotante para ver conflictos -->
    <button
      id="conflictsToggle"
      class="fixed bottom-6 left-6 bg-red-600 text-white p-3 rounded-full shadow-lg hover:bg-red-700 transition-colors z-40"
      title="Ver conflictos de la semana"
    >
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
      </svg>
      <span id="floatingConflictsBadge" class="absolute -top-2 -right-2 bg-yellow-500 text-white text-xs w-6 h-6 rounded-full flex items-center justify-center hidden">0</span>
    </button>
  </div>
</Layout>

<script>
  // DeclaraciÃ³n de tipos para funciones globales
  declare global {
    interface Window {
      clearUsersCache: () => void;
    }
  }

  // Inicializar fecha desde el parÃ¡metro URL o fecha actual
  const urlParams = new URLSearchParams(window.location.search);
  const dateParam = urlParams.get('date');
  let currentDate = dateParam ? new Date(dateParam) : new Date();
  
  const days = [
    "lunes",
    "martes",
    "miercoles",
    "jueves",
    "viernes",
    "sabado",
    "domingo",
  ];
  
  // Obtener referencias DOM al inicio para evitar errores
  const spinnerOverlay = document.getElementById("spinnerOverlay");

  // OPTIMIZACIÃ“N: Cache de usuarios para evitar mÃºltiples consultas
  let allUsersCache = null;

  // NUEVO: Tracking de cambios sin guardar
  let hasUnsavedChanges = false;
  
  // OPTIMIZACIÃ“N: MemoizaciÃ³n para cÃ¡lculos costosos
  const memoCache = new Map();
  
  const memoize = (fn, keyGenerator) => {
    return function (...args) {
      const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);
      
      if (memoCache.has(key)) {
        return memoCache.get(key);
      }
      
      const result = fn.apply(this, args);
      memoCache.set(key, result);
      
      // Limpiar cachÃ© despuÃ©s de 5 minutos para evitar memory leaks
      setTimeout(() => {
        memoCache.delete(key);
      }, 5 * 60 * 1000);
      
      return result;
    };
  };
  
  // OPTIMIZACIÃ“N: Debouncing para validaciones
  const validationTimeouts = new Map();
  
  const debounce = (func, delay) => {
    return function (...args) {
      const key = args[0]?.dataset ? `${args[0].dataset.day}-${args[0].dataset.turno}-${args[0].dataset.index}` : 'default';
      
      // Cancelar timeout anterior si existe
      if (validationTimeouts.has(key)) {
        clearTimeout(validationTimeouts.get(key));
      }
      
      // Crear nuevo timeout
      const timeoutId = setTimeout(() => {
        func.apply(this, args);
        validationTimeouts.delete(key);
      }, delay);
      
      validationTimeouts.set(key, timeoutId);
    };
  };
  
  // OPTIMIZACIÃ“N: Funciones de debouncing removidas - ahora se cargan todos los usuarios de una vez
  
  // Function to populate select with users
  const populateSelect = (select, users) => {
    // Limpiar el select y agregar opciones por defecto
    select.innerHTML = `
      <option value=""></option>
      <option value="--separator--" disabled>Seleccionar usuario...</option>
    `;
    
    users.forEach(user => {
      // Validar que tenemos los datos bÃ¡sicos necesarios
      if (!user.nombre || !user.userName) {
        console.warn('Usuario sin nombre o userName:', user);
        return;
      }
      
      let displayName = user.nombre;
      let statusIcon = '';
      
      // Agregar badges de privilegios
      if (user.privilegios && Array.isArray(user.privilegios)) {
        const isCapitan = user.privilegios.some(p => p && p.toLowerCase() === 'capitan');
        const otherPrivileges = user.privilegios
          .filter(p => p && p.toLowerCase() !== 'capitan')
          .map(p => p.charAt(0).toUpperCase())
          .join("");
        
        if (isCapitan) {
          displayName = `[C] ${user.nombre}`;
        }
        if (otherPrivileges) {
          displayName += ` [${otherPrivileges}]`;
        }
      }
      
      // Agregar indicadores de estado
      if (user.canParticipate === false) {
        statusIcon = ' ðŸš«';
        if (user.validationMessage) {
          displayName += ` (${user.validationMessage})`;
        }
      } else if (user.validationMessage) {
        statusIcon = ' âš ï¸';
      } else if (user.participation_rules && Array.isArray(user.participation_rules) && user.participation_rules.length > 0) {
        statusIcon = ' âš ï¸';
      } else {
        statusIcon = ' âœ…';
      }
      
      const option = document.createElement('option');
      option.value = user.userName;
      option.textContent = displayName + statusIcon;
      option.dataset.congregacionId = user.congregacion?.id || '';
      option.dataset.participationRules = JSON.stringify(user.participation_rules || []);
      option.disabled = user.canParticipate === false;
      
      select.appendChild(option);
    });
    
    // Agregar opciÃ³n de aÃ±adir usuario
    const addOption = document.createElement('option');
    addOption.value = 'add';
    addOption.textContent = 'AÃ±adir usuario';
    select.appendChild(addOption);
  };
  
  // Function to populate all selects with filtered users
  const populateAllSelects = (allUsers) => {
    // Vista Ãºnica responsiva
    const selects = document.querySelectorAll<HTMLSelectElement>('.user-select');
    selects.forEach(select => {
      const day = select.dataset.day;
      const turno = select.dataset.turno;
      const date = select.dataset.date;
      
      // Filtrar usuarios disponibles para este dÃ­a y turno
      const availableUsers = allUsers.filter(user => {
        if (!user.disponibilidad) return false;
        
        try {
          const disponibilidad = typeof user.disponibilidad === "string"
            ? JSON.parse(user.disponibilidad)
            : user.disponibilidad;
            
          return disponibilidad[day] && disponibilidad[day].includes(turno);
        } catch {
          return false;
        }
      });
      
      // Poblar el select con usuarios disponibles
      populateSelect(select, availableUsers);
    });
  };
  
  // Function to load all users once and apply to all selects
  const loadAllUsers = async () => {
    try {
      // Si ya tenemos usuarios en cachÃ©, usar esos
      if (allUsersCache) {
        populateAllSelects(allUsersCache);
        return;
      }
      
      // Cargar todos los usuarios activos una sola vez
      const response = await fetch('/api/getUsersForProgram.json?activeOnly=true');
      if (!response.ok) {
        throw new Error('Error loading users');
      }
      
      const { data: allUsers } = await response.json();
      allUsersCache = allUsers;
      
      populateAllSelects(allUsers);
      
    } catch (error) {
      console.error('Error loading users:', error);
      // En caso de error, mostrar mensaje en todos los selects
      const selects = document.querySelectorAll('.user-select');
      selects.forEach(select => {
        select.innerHTML = `
          <option value=""></option>
          <option value="--error--" disabled>Error cargando usuarios</option>
        `;
      });
    }
  };
  
  // Function to update precursor background for a select
  const updatePrecursorBackground = (select, userName) => {
    if (!userName) {
      // Remover estilo de precursor
      select.classList.remove('precursor-select');
      // TambiÃ©n buscar contenedor padre si existe
      const container = select.closest('.flex');
      if (container) {
        container.classList.remove('precursor-container');
      }
      return;
    }
    
    // Verificar si el usuario es precursor revisando el texto de display
    const selectedOption = select.options[select.selectedIndex];
    if (selectedOption) {
      const displayText = selectedOption.textContent || '';
      const isPrecursor = displayText.toLowerCase().includes('precursor') || 
                         displayText.includes('[P]');
      
      if (isPrecursor) {
        // Aplicar estilo de precursor
        select.classList.add('precursor-select');
        // TambiÃ©n al contenedor padre si existe
        const container = select.closest('.flex');
        if (container) {
          container.classList.add('precursor-container');
        }
      } else {
        // Remover estilo de precursor
        select.classList.remove('precursor-select');
        const container = select.closest('.flex');
        if (container) {
          container.classList.remove('precursor-container');
        }
      }
    }
  };

  // Function to clear users cache (useful when week changes)
  const clearUsersCache = () => {
    allUsersCache = null;
    memoCache.clear(); // Limpiar tambiÃ©n el cache de memoizaciÃ³n
    validationStates.clear(); // Limpiar estados de validaciÃ³n
    userNameMappingCache = null; // Limpiar cache de nombres
    console.log('Cache cleared for week change');
  };

  // Vista Ãºnica responsiva - no necesita sincronizaciÃ³n
  // Asegurar que syncViewValues no existe (evitar errores de cache)
  (window as any).syncViewValues = undefined;

  // Exponer funciÃ³n globalmente para navegaciÃ³n
  window.clearUsersCache = clearUsersCache;
  
  // Event listener para detectar cambios de pÃ¡gina y limpiar cache
  window.addEventListener('beforeunload', (event) => {
    clearUsersCache();

    // Advertir al usuario si hay cambios sin guardar
    if (hasUnsavedChanges) {
      event.preventDefault();
      // Mensaje estÃ¡ndar del navegador (el texto personalizado ya no funciona en navegadores modernos)
      return 'Tiene cambios sin guardar. Â¿EstÃ¡ seguro que desea salir?';
    }
  });

  // FunciÃ³n para marcar que hay cambios sin guardar
  const markAsChanged = () => {
    if (!hasUnsavedChanges) {
      hasUnsavedChanges = true;
      // Actualizar UI para indicar cambios pendientes
      const saveBtn = document.getElementById('saveBtn');
      if (saveBtn && !saveBtn.textContent.includes('*')) {
        saveBtn.textContent = '* Guardar Programa';
        saveBtn.classList.add('animate-pulse');
      }
    }
  };

  // FunciÃ³n para marcar que los cambios fueron guardados
  const markAsSaved = () => {
    hasUnsavedChanges = false;
    const saveBtn = document.getElementById('saveBtn');
    if (saveBtn) {
      saveBtn.textContent = 'Guardar Programa';
      saveBtn.classList.remove('animate-pulse');
    }
  };

  // OPTIMIZACIÃ“N: FunciÃ³n unificada para cargar datos de semana
  const fetchWeekDataFromAPI = async (date: Date) => {
    try {
      const response = await fetch(
        `/api/getWeekData.json?date=${date.toISOString().split("T")[0]}`
      );
      return await response.json();
    } catch (error) {
      console.error("Error fetching week data:", error);
      return {};
    }
  };

  // OPTIMIZACIÃ“N: Memoizar el cÃ¡lculo de inicio de semana
  const getStartOfWeek = memoize((date) => {
    const startOfWeek = new Date(date);
    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay() + 1);
    return startOfWeek;
  }, (date) => `start-week-${new Date(date).toISOString().split('T')[0]}`);

  // Function to load week data and apply to UI
  const loadWeekData = async () => {
    // Calculate the start date of the week (memoized)
    const startOfWeek = getStartOfWeek(currentDate);

    try {
      // Show spinner
      spinnerOverlay.classList.add("active");
      
      // Limpiar cache cuando se cambia de semana
      clearUsersCache();
      
      // Cargar usuarios para todos los selects (usa cache si estÃ¡ disponible)
      await loadAllUsers();

      const currentWeekData = await fetchWeekDataFromAPI(startOfWeek);
      
      // Para usuarios que necesitamos buscar su informaciÃ³n completa
      const usersToFetch = new Set();
      
      // Primera pasada: identificar usuarios que necesitamos buscar
      document.querySelectorAll("select").forEach((select) => {
        const day = select.dataset.day;
        const turno = select.dataset.turno;
        const index = select.dataset.index;
        const savedValue = currentWeekData[`${day}-${turno}-${index}`] || "";
        
        if (savedValue) {
          const optionExists = Array.from(select.options).some(
            (option) => option.value === savedValue
          );
          
          if (!optionExists) {
            usersToFetch.add(savedValue);
          }
        }
      });
      
      // Si hay usuarios que buscar, obtener su informaciÃ³n
      let additionalUsers = {};
      if (usersToFetch.size > 0) {
        try {
          const response = await fetch('/api/getUsersForProgram.json?activeOnly=false');
          if (response.ok) {
            const { data: allUsers } = await response.json();
            allUsers.forEach(user => {
              if (usersToFetch.has(user.userName)) {
                additionalUsers[user.userName] = user;
              }
            });
          }
        } catch (error) {
          console.warn('Error fetching additional user info:', error);
        }
      }
      
      // Segunda pasada: aplicar valores y crear opciones si es necesario
      document.querySelectorAll<HTMLSelectElement>("select.user-select").forEach((select) => {
        const day = select.dataset.day;
        const turno = select.dataset.turno;
        const index = select.dataset.index;
        const savedValue = currentWeekData[`${day}-${turno}-${index}`] || "";
        
        if (savedValue) {
          // Verificar si la opciÃ³n existe
          const optionExists = Array.from(select.options).some(
            (option) => option.value === savedValue
          );
          
          if (!optionExists) {
            // Si el usuario guardado no estÃ¡ en las opciones, aÃ±adirlo
            const newOption = document.createElement("option");
            newOption.value = savedValue;
            
            // Buscar informaciÃ³n del usuario
            const userInfo = additionalUsers[savedValue];
            if (userInfo) {
              // Construir el texto de display con privilegios
              let displayText = userInfo.nombre;
              
              if (userInfo.privilegios && Array.isArray(userInfo.privilegios)) {
                const isCapitan = userInfo.privilegios.some(p => p && p.toLowerCase() === 'capitan');
                const otherPrivileges = userInfo.privilegios
                  .filter(p => p && p.toLowerCase() !== 'capitan')
                  .map(p => p.charAt(0).toUpperCase())
                  .join("");
                
                if (isCapitan) displayText = `[C] ${userInfo.nombre}`;
                if (otherPrivileges) displayText += ` [${otherPrivileges}]`;
              }
              
              // Indicador de no disponible
              displayText += ' (no disponible) âš ï¸';
              
              newOption.textContent = displayText;
              newOption.dataset.congregacionId = userInfo.congregacion?.id || '';
              newOption.dataset.participationRules = JSON.stringify(userInfo.participation_rules || []);
              newOption.style.color = '#666';
              newOption.style.fontStyle = 'italic';
            } else {
              // Fallback si no encontramos la info
              newOption.textContent = `${savedValue} (no disponible) âš ï¸`;
              newOption.style.color = '#666';
              newOption.style.fontStyle = 'italic';
            }
            
            // Insertar antes de la opciÃ³n "AÃ±adir usuario"
            const addOption = Array.from(select.options).find(opt => opt.value === "add");
            if (addOption) {
              select.insertBefore(newOption, addOption);
            } else {
              select.appendChild(newOption);
            }
          }
        }
        
        select.value = savedValue;
        
        // Actualizar fondo de precursor para valores cargados
        updatePrecursorBackground(select, savedValue);
      });

      // Hide spinner
      spinnerOverlay.classList.remove("active");
    } catch (error) {
      console.error("Error loading week data:", error);
      // Hide spinner in case of error
      spinnerOverlay.classList.remove("active");
    }
  };

  document
    .getElementById("preajustesSelect")
    .addEventListener("change", async (event) => {
      const target = event.target as HTMLSelectElement;
      const selectedOption = target.value;

      if (selectedOption === "guardar") {
        await savePreajustesData();
        notify.success(`Preajuste guardado exitosamente`);
        //alert("Preajuste guardado exitosamente");
      } else if (selectedOption === "cargar") {
        //const preajusteName = prompt("Introduce:  Preajuste1 ");
        const preajusteName = "Preajuste1";
        if (preajusteName) {
          await loadPreajustesData(preajusteName);
          //alert("Preajuste cargado exitosamente");
          notify.success(`Preajuste cargado exitosamente`);
        }
      }

      // Reset the select to the default option
      target.value = "";
    });

  //   // Function to load preajustes data
  const loadPreajustesData = async (
    preajusteName: string | number | boolean
  ) => {
    try {
      const response = await fetch(
        `/api/getPreajustesData.json?name=${encodeURIComponent(preajusteName)}`
      );
      const preajustesData = await response.json();
      document.querySelectorAll<HTMLSelectElement>("select.user-select").forEach((select) => {
        const day = select.dataset.day;
        const turno = select.dataset.turno;
        const index = select.dataset.index;
        const value = preajustesData[`${day}-${turno}-${index}`] || "";
        select.value = value;
      });
    } catch (error) {
      console.error("Error loading preajustes data:", error);
    }
  };

  // Function to save week data
  // CORREGIDO: Ahora procesa TODOS los selects sin importar visibilidad en mobile
  const saveWeekData = async () => {
    const currentWeekData = {};
    const startOfWeek = new Date(currentDate);
    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay() + 1);
    const weekDate = startOfWeek.toISOString().split("T")[0];

    // Show spinner al inicio
    spinnerOverlay.classList.add("active");

    let totalSelects = 0;
    let savedSelects = 0;

    // CORREGIDO: Procesar TODOS los selects sin filtrar por visibilidad
    const selects = document.querySelectorAll<HTMLSelectElement>("select.user-select");

    for (const select of selects) {
      totalSelects++;

      const day = select.dataset.day;
      const turno = select.dataset.turno;
      const index = select.dataset.index;
      const userName = select.value;

      // Validar que tenemos todos los datos necesarios
      if (!day || !turno || index === undefined) {
        console.warn('Select sin datos completos:', { day, turno, index, userName });
        continue;
      }

      if (userName && userName !== "--separator--" && userName !== "--error--" && userName !== "add") {
        // Guardar si hay un usuario real seleccionado
        currentWeekData[`${day}-${turno}-${index}`] = userName;
        savedSelects++;
      }
    }

    // Guardar datos de la semana (el historial se guarda automÃ¡ticamente en el backend)
    const response = await fetch("/api/saveWeekData.json", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        date: weekDate,
        weekData: currentWeekData,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      spinnerOverlay.classList.remove("active");
      throw new Error(`Error ${response.status}: ${errorData.error}`);
    }

    // Hide spinner
    spinnerOverlay.classList.remove("active");

    // Marcar que los cambios fueron guardados
    markAsSaved();

    // Log de debug
    console.log(`Guardado completado: ${totalSelects} selects totales, ${savedSelects} con datos, ${Object.keys(currentWeekData).length} guardados`);
  };

  // Function to save preajustes data
  // CORREGIDO: Usar for...of en lugar de forEach con async
  const savePreajustesData = async () => {
    const preajustesData = {};
    const preajusteName = "Preajuste1";

    const selects = document.querySelectorAll<HTMLSelectElement>("select.user-select");

    for (const select of selects) {
      const day = select.dataset.day;
      const turno = select.dataset.turno;
      const index = select.dataset.index;
      const userName = select.value;

      if (userName && userName !== "--separator--" && userName !== "--error--" && userName !== "add") {
        preajustesData[`${day}-${turno}-${index}`] = userName;
      }
    }

    await fetch("/api/savePreajustesData.json", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        name: preajusteName, // Use the preajuste name
        preajusteData: preajustesData,
      }),
    });
  };

  // Function to update week dates in the UI
  const updateWeekDates = () => {
    const dates = getWeekDates(currentDate);
    document.querySelectorAll(".week-date").forEach((element, index) => {
      element.textContent = `${days[index].charAt(0).toUpperCase() + days[index].slice(1)} - ${dates[index].toLocaleDateString()}`;
    });
  };

  
  // Function to get week dates (memoized)
  const getWeekDates = memoize((currentDate: string | number | Date) => {
    const startOfWeek = new Date(currentDate);
    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay() + 1);
    const dates = [];
    for (let i = 0; i < 7; i++) {
      const date = new Date(startOfWeek);
      date.setDate(startOfWeek.getDate() + i);
      dates.push(date);
    }
    return dates;
  }, (date) => `week-dates-${new Date(date).toISOString().split('T')[0]}`);

  // Buscador para el modal
  document.getElementById("userSearch").addEventListener("input", function () {
    const searchValue = (this as HTMLInputElement).value.toLowerCase();
    const userList = document.getElementById("userList");
    const users = userList.getElementsByTagName("li");

    Array.from(users).forEach((user) => {
      const userName = user
        .getElementsByTagName("button")[0]
        .dataset.username.toLowerCase();
      if (userName.includes(searchValue)) {
        user.style.display = "";
      } else {
        user.style.display = "none";
      }
    });
  });

  // Los botones de navegaciÃ³n ahora se manejan en el componente WeekNavigation

  import { Notyf } from "notyf";
  import "notyf/notyf.min.css";
  import { ParticipationValidatorJS } from "../../utils/participationValidator";
  import { undoRedoManager, type ChangeRecord } from "../../stores/undoRedoStore";
  import type { WeekDay, Turno } from "../../types/program";

  // Sistema de gestiÃ³n de notificaciones
  let notificationsStore = [];
  let notificationIdCounter = 0;

  const NotificationManager = {
    add(type, message) {
      const notification = {
        id: ++notificationIdCounter,
        type: type,
        message: message,
        timestamp: new Date(),
        read: false
      };
      
      notificationsStore.unshift(notification); // Agregar al principio
      
      // Mantener solo las Ãºltimas 50 notificaciones
      if (notificationsStore.length > 50) {
        notificationsStore = notificationsStore.slice(0, 50);
      }
      
      this.updateUI();
      return notification;
    },

    clear() {
      notificationsStore = [];
      this.updateUI();
    },

    markAsRead(id) {
      const notification = notificationsStore.find(n => n.id === id);
      if (notification) {
        notification.read = true;
        this.updateUI();
      }
    },

    getIconForType(type) {
      switch(type) {
        case 'error': return 'âŒ';
        case 'warning': return 'âš ï¸';
        case 'info': return 'â„¹ï¸';
        case 'success': return 'âœ…';
        default: return 'ðŸ“¢';
      }
    },

    getColorForType(type) {
      switch(type) {
        case 'error': return 'bg-red-50 border-red-200 text-red-800';
        case 'warning': return 'bg-orange-50 border-orange-200 text-orange-800';
        case 'info': return 'bg-blue-50 border-blue-200 text-blue-800';
        case 'success': return 'bg-green-50 border-green-200 text-green-800';
        default: return 'bg-gray-50 border-gray-200 text-gray-800';
      }
    },

    updateUI() {
      const count = notificationsStore.length;
      const unreadCount = notificationsStore.filter(n => !n.read).length;

      // Actualizar contador en panel
      const notificationCount = document.getElementById('notificationCount');
      if (notificationCount) notificationCount.textContent = String(count);

      // Actualizar badge flotante
      const floatingBadge = document.getElementById('floatingNotificationBadge');
      if (floatingBadge) {
        if (unreadCount > 0) {
          floatingBadge.textContent = String(unreadCount);
          floatingBadge.classList.remove('hidden');
        } else {
          floatingBadge.classList.add('hidden');
        }
      }
      
      // Actualizar lista
      this.renderNotifications();
    },

    renderNotifications() {
      const container = document.getElementById('notificationsList');
      
      if (notificationsStore.length === 0) {
        container.innerHTML = `
          <div class="text-center text-gray-500 py-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-3 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-5 5-5-5h5V3h0z" />
            </svg>
            <p>No hay notificaciones</p>
          </div>
        `;
        return;
      }

      container.innerHTML = notificationsStore.map(notification => {
        const timeStr = notification.timestamp.toLocaleTimeString('es-ES', { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
        
        return `
          <div class="mb-3 p-3 border rounded-lg ${this.getColorForType(notification.type)} ${!notification.read ? 'ring-2 ring-blue-200' : ''}" 
               data-notification-id="${notification.id}">
            <div class="flex items-start justify-between">
              <div class="flex items-start space-x-2 flex-1">
                <span class="text-lg">${this.getIconForType(notification.type)}</span>
                <div class="flex-1">
                  <p class="text-sm font-medium">${notification.message}</p>
                  <p class="text-xs mt-1 opacity-70">${timeStr}</p>
                </div>
              </div>
              ${!notification.read ? '<div class="w-2 h-2 bg-blue-600 rounded-full flex-shrink-0 mt-1"></div>' : ''}
            </div>
          </div>
        `;
      }).join('');
      
      // Agregar event listeners para marcar como leÃ­da
      container.querySelectorAll<HTMLElement>('[data-notification-id]').forEach(item => {
        item.addEventListener('click', () => {
          const id = parseInt(item.dataset.notificationId || '0');
          this.markAsRead(id);
        });
      });
    }
  };

  // Event listeners para el panel
  document.addEventListener('DOMContentLoaded', () => {
    const panel = document.getElementById('notificationsPanel');
    const toggleBtn = document.getElementById('notificationsToggle');
    const closeBtn = document.getElementById('closeNotificationsBtn');
    const clearBtn = document.getElementById('clearNotificationsBtn');

    toggleBtn.addEventListener('click', () => {
      panel.classList.toggle('hidden');
    });

    closeBtn.addEventListener('click', () => {
      panel.classList.add('hidden');
    });

    clearBtn.addEventListener('click', () => {
      NotificationManager.clear();
    });

    // Cerrar panel al hacer clic fuera
    document.addEventListener('click', (event) => {
      const target = event.target as Node;
      if (panel && toggleBtn && !panel.contains(target) && !toggleBtn.contains(target)) {
        panel.classList.add('hidden');
      }
    });
  });

  // Crear una instancia de Notyf con configuraciÃ³n para advertencias
  const notyf = new Notyf({
    duration: 6000,
    position: {
      x: 'right',
      y: 'top',
    },
    types: [
      {
        type: 'warning',
        background: 'orange',
        icon: {
          className: 'notyf__icon--warning',
          tagName: 'span',
          text: 'âš ï¸'
        }
      },
      {
        type: 'info',
        background: 'blue',
        icon: {
          className: 'notyf__icon--info', 
          tagName: 'span',
          text: 'â„¹ï¸'
        }
      }
    ]
  });

  // Wrapper para integrar Notyf con nuestro panel de notificaciones
  const notify = {
    success(message) {
      notyf.success(message);
      NotificationManager.add('success', message);
    },
    
    error(message) {
      notyf.error(message);
      NotificationManager.add('error', message);
    },
    
    warning(message) {
      notyf.open({ type: 'warning', message });
      NotificationManager.add('warning', message);
    },
    
    info(message) {
      notyf.open({ type: 'info', message });
      NotificationManager.add('info', message);
    },
    
    open(options) {
      notyf.open(options);
      NotificationManager.add(options.type || 'info', options.message);
    }
  };

  // Hacer notify global para que pueda ser usado desde otros mÃ³dulos
  (window as any).notify = notify;

  // Load week data when the DOM is fully loaded
  document.addEventListener("DOMContentLoaded", async () => {
    await loadWeekData();
    
    // Agregar event listeners para los selects despuÃ©s de cargar
    document.querySelectorAll<HTMLSelectElement>("select.user-select").forEach((select) => {
      // Guardar valor previo para undo/redo
      let previousValue = select.value;

      select.addEventListener("focus", () => {
        // Capturar valor antes del cambio
        previousValue = select.value;
      });

      select.addEventListener("change", (event) => {
        const target = event.target as HTMLSelectElement;
        const newValue = target.value;

        // Registrar cambio para undo/redo (solo si no es "add" que abre modal)
        if (newValue !== "add" && previousValue !== newValue) {
          recordSelectChange(select, previousValue, newValue);
        }

        // Marcar que hay cambios sin guardar
        markAsChanged();

        if (target.value === "add") {
          const day = select.dataset.day;
          const turno = select.dataset.turno;
          const index = select.dataset.index;

          // Obtener referencias a elementos del modal
          const modal = document.getElementById("userModal");
          const userList = document.getElementById("userList");

          // Abrir el modal cuando se seleccione "AÃ±adir usuario"
          modal.classList.remove("hidden");
          modal.dataset.day = day;
          modal.dataset.turno = turno;
          modal.dataset.index = index;
          // Guardar valor previo para undo/redo
          modal.dataset.previousValue = previousValue;
          
          // Cargar usuarios dinÃ¡micamente en el modal
          userList.innerHTML = '<li class="text-center py-4 text-gray-500">Cargando usuarios...</li>';
          
          // Cargar usuarios activos para el modal
          const loadModalUsers = async () => {
            try {
              const response = await fetch('/api/getUsersForProgram.json?activeOnly=true');
              if (response.ok) {
                const { data: users } = await response.json();
                
                // Ordenar alfabÃ©ticamente
                users.sort((a, b) => a.nombre.localeCompare(b.nombre));
                
                // Limpiar lista
                userList.innerHTML = '';
                
                // Agregar usuarios
                users.forEach(user => {
                  const isCapitan = user.privilegios && Array.isArray(user.privilegios) && 
                    user.privilegios.some(p => p.toLowerCase() === 'capitan');
                  const otherPrivileges = user.privilegios && Array.isArray(user.privilegios) ?
                    user.privilegios
                      .filter(p => p.toLowerCase() !== 'capitan')
                      .map(p => p.charAt(0).toUpperCase())
                      .join("") : "";
                  
                  const hasRestrictions = user.participation_rules && 
                    Array.isArray(user.participation_rules) && 
                    user.participation_rules.length > 0;
                  
                  const li = document.createElement('li');
                  li.className = 'mb-2';
                  
                  const button = document.createElement('button');
                  button.className = 'bg-cyan-600 text-white w-full px-2 py-1 rounded user-select-btn hover:bg-cyan-700 transition-colors text-left';
                  button.dataset.username = user.userName;
                  button.dataset.congregacionId = user.congregacion?.id || '';
                  button.dataset.participationRules = JSON.stringify(user.participation_rules || []);
                  
                  let displayText = '';
                  if (isCapitan) displayText += '[C] ';
                  displayText += user.nombre;
                  if (otherPrivileges) displayText += ` [${otherPrivileges}]`;
                  if (hasRestrictions) displayText += ' âš ï¸';
                  
                  button.textContent = displayText;
                  
                  // Agregar event listener al botÃ³n
                  button.addEventListener("click", async function handleUserSelection(event) {
                    const newUserName = button.dataset.username;
                    const participationRules = button.dataset.participationRules;
                    
                    if (newUserName) {
                      // Capturar valor previo para undo/redo (guardado en el modal al abrirlo)
                      const modalPreviousValue = modal.dataset.previousValue || '';

                      // Verificar si la opciÃ³n ya existe
                      const existingOption = Array.from(select.options).find(opt => opt.value === newUserName);
                      if (!existingOption) {
                        // Crear nueva opciÃ³n con toda la informaciÃ³n del usuario
                        const newOption = document.createElement("option");
                        newOption.value = newUserName;
                        newOption.textContent = displayText; // Usar el displayText con privilegios
                        newOption.dataset.congregacionId = user.congregacion?.id || '';
                        newOption.dataset.participationRules = participationRules || '[]';

                        // Insertar antes de la opciÃ³n "AÃ±adir usuario"
                        const addOption = Array.from(select.options).find(opt => opt.value === "add");
                        if (addOption) {
                          select.insertBefore(newOption, addOption);
                        } else {
                          select.appendChild(newOption);
                        }
                      }

                      // Actualizar el valor del select
                      select.value = newUserName;

                      // Registrar cambio para undo/redo
                      if (modalPreviousValue !== newUserName) {
                        recordSelectChange(select, modalPreviousValue, newUserName);
                      }

                      // Verificar si es precursor y mostrar fondo verde
                      updatePrecursorBackground(select, newUserName);

                      // Verificar las asignaciones despuÃ©s de aÃ±adir un usuario
                      await checkUserAssignment(select);

                      // Cerrar el modal
                      modal.classList.add("hidden");
                    }
                  });
                  
                  li.appendChild(button);
                  userList.appendChild(li);
                });
                
                // Aplicar filtro de bÃºsqueda si existe
                const searchInput = document.getElementById("userSearch") as HTMLInputElement;
                if (searchInput && searchInput.value) {
                  searchInput.dispatchEvent(new Event('input'));
                }
              } else {
                userList.innerHTML = '<li class="text-center py-4 text-red-500">Error cargando usuarios</li>';
              }
            } catch (error) {
              console.error('Error loading modal users:', error);
              userList.innerHTML = '<li class="text-center py-4 text-red-500">Error de conexiÃ³n</li>';
            }
          };
          
          loadModalUsers();
          
        } else if (select.value !== "") {
          // Verificar si es precursor y mostrar fondo verde
          updatePrecursorBackground(select, select.value);
          
          // ValidaciÃ³n inmediata para feedback visual rÃ¡pido
          const icon = document.getElementById(`icon-${select.dataset.day}-${select.dataset.turno}-${select.dataset.index}`);
          if (icon) {
            icon.innerHTML = "â³"; // Mostrar que se estÃ¡ validando
          }
          
          // ValidaciÃ³n completa con debounce para evitar spam de API
          debouncedValidation(select);
        } else {
          // Si se vacÃ­a el select, quitar fondo de precursor
          updatePrecursorBackground(select, "");
        }
      });
    });
    
    // Add event listener for save button
    const saveBtn = document.getElementById("saveBtn");
    if (saveBtn) {
      saveBtn.addEventListener("click", async () => {
        try {
          await saveWeekData();
          notify.success("Guardado correctamente");
        } catch (error) {
          console.error('Error al guardar:', error);
          notify.error(`Error al guardar: ${error.message}`);
        }
      });
    }
    
    // Add event listeners for close modal buttons
    const closeModalBtn = document.getElementById("closeModalBtn");
    const closeModalBtnFooter = document.getElementById("closeModalBtnFooter");
    
    if (closeModalBtn) {
      closeModalBtn.addEventListener("click", () => {
        const modal = document.getElementById("userModal");
        modal.classList.add("hidden");
      });
    }
    
    if (closeModalBtnFooter) {
      closeModalBtnFooter.addEventListener("click", () => {
        const modal = document.getElementById("userModal");
        modal.classList.add("hidden");
      });
    }
    
    // Add event listener for close warning button
    const closeWarningBtn = document.getElementById("closeWarningBtn");
    if (closeWarningBtn) {
      closeWarningBtn.addEventListener("click", () => {
        const warningPopup = document.getElementById("warningPopup");
        if (warningPopup) warningPopup.classList.add("hidden");
      });
    }
    
    // Set initial values after loading
    setTimeout(() => {
      document.querySelectorAll<HTMLSelectElement>("select.user-select").forEach((select) => {
        const key = `${select.dataset.day}-${select.dataset.turno}-${select.dataset.index}`;
        initialSelectValues[key] = select.value;
      });
    }, 1000);
  });

  // Cache para mapeo de nombres
  let userNameMappingCache = null;
  
  // FunciÃ³n para obtener el nombre completo del usuario
  const getUserFullName = async (userName) => {
    try {
      // Si no tenemos cache, cargar el mapeo
      if (!userNameMappingCache) {
        const response = await fetch('/api/getUsersNameMapping.json');
        const data = await response.json();
        userNameMappingCache = data.mapping || {};
      }
      return userNameMappingCache[userName] || userName; // Fallback al userName si no se encuentra
    } catch (error) {
      console.error('Error fetching user name mapping:', error);
      return userName; // Fallback en caso de error
    }
  };

  // Function to check user assignment with participation rules validation
  async function checkUserAssignment(select: HTMLSelectElement) {
    const userName = select.value;
    const day = select.dataset.day;
    const turno = select.dataset.turno;
    const index = select.dataset.index;
    const stateKey = `${day}-${turno}-${index}`;
    const icon = document.getElementById(`icon-${day}-${turno}-${index}`);
    
    // Obtener estado previo
    const previousState = validationStates.get(stateKey);
    
    // Obtener nombre completo del usuario
    const fullName = await getUserFullName(userName);

    // Si el select estÃ¡ vacÃ­o
    if (!userName) {
      // Si habÃ­a un usuario con restricciones antes, notificar que ya no hay restricciones
      if (previousState && (previousState.hasRestrictions || previousState.hasWarnings)) {
        notify.open({
          type: 'info',
          message: `${day} ${turno} posiciÃ³n ${parseInt(index) + 1}: Sin restricciones (vacÃ­o)`
        });
      }
      validationStates.delete(stateKey);
      if (icon) icon.innerHTML = "";
      return;
    }

    const selectedDate = new Date(select.dataset.date);

    // Verificar si el usuario ya estÃ¡ asignado en otro turno de la semana
    const assignedTurns: string[] = [];
    document.querySelectorAll<HTMLSelectElement>("select.user-select").forEach((otherSelect) => {
      if (otherSelect !== select && otherSelect.value === userName) {
        const otherDay = otherSelect.dataset.day;
        const otherTurno = otherSelect.dataset.turno;
        assignedTurns.push(`${otherDay} en el turno ${otherTurno}`);
      }
    });

    // Verificar conflictos de asignaciÃ³n mÃºltiple
    if (assignedTurns.length > 0) {
      if (icon) {
        icon.innerHTML = "âš ï¸"; // Icono para ya asignado
      }
      
      // Solo mostrar error si es nuevo o cambiÃ³ de usuario
      const wasAnotherUser = previousState && previousState.userName !== userName;
      if (!previousState || wasAnotherUser) {
        notify.error(
          `${fullName} ya participa esta semana en ${assignedTurns.join(", ")}.`
        );
      }
      
      // Guardar estado de conflicto
      validationStates.set(stateKey, {
        userName: userName,
        hasRestrictions: true, // Conflicto cuenta como restricciÃ³n
        hasWarnings: false,
        canParticipate: false
      });
      
      return;
    }

    // Obtener reglas de participaciÃ³n del usuario
    const selectedOption = select.options[select.selectedIndex];
    const participationRules = selectedOption.getAttribute('data-participation-rules');
    
    if (participationRules && participationRules !== '[]') {
      try {
        // OPTIMIZACIÃ“N: Memoizar el parseado de reglas de participaciÃ³n
        const parseRules = memoize((rulesString) => {
          return JSON.parse(rulesString);
        }, (rulesString) => `rules-${rulesString}`);
        
        const parsedRules = parseRules(participationRules);
        
        // MOSTRAR CONDICIONES DEL USUARIO (solo si es nuevo o cambiÃ³ de usuario)
        const isNewOrChanged = !previousState || previousState.userName !== userName;
        if (isNewOrChanged) {
          const conditionsDescriptions: string[] = [];
          
          parsedRules.forEach((rule: any) => {
            switch (rule.type) {
              case 'max_per_month':
                conditionsDescriptions.push(`MÃ¡ximo ${rule.value} ${rule.value === 1 ? 'vez' : 'veces'} al mes`);
                break;
              case 'max_per_week':
                conditionsDescriptions.push(`MÃ¡ximo ${rule.value} ${rule.value === 1 ? 'vez' : 'veces'} por semana`);
                break;
              case 'specific_weeks':
                const weeks = Array.isArray(rule.value) ? rule.value : [rule.value];
                conditionsDescriptions.push(`Solo puede participar en las semanas: ${weeks.join(', ')}`);
                break;
              case 'alternating_weeks':
                conditionsDescriptions.push(`Participa en semanas alternadas (una sÃ­, una no)`);
                break;
              case 'weekly_availability':
                conditionsDescriptions.push(`EnvÃ­a su disponibilidad semanalmente`);
                break;
              default:
                if (rule.description) {
                  conditionsDescriptions.push(rule.description);
                }
                break;
            }
          });
          
          if (conditionsDescriptions.length > 0) {
            const conditionsMessage = `ðŸ” Condiciones de ${fullName}: ${conditionsDescriptions.join(' â€¢ ')}`;
            notify.info(conditionsMessage);
          }
        }
        
        // Validar reglas de participaciÃ³n
        const validation = await ParticipationValidatorJS.validateUserForDate(
          userName, 
          parsedRules, 
          selectedDate
        );

        // Crear estado actual
        const currentState = {
          userName: userName,
          hasRestrictions: !validation.canParticipate,
          hasWarnings: validation.warnings && validation.warnings.length > 0,
          canParticipate: validation.canParticipate
        };
        
        // Comparar con estado previo
        const hadPreviousRestrictions = previousState && previousState.hasRestrictions;
        const hadPreviousWarnings = previousState && previousState.hasWarnings;
        const wasAnotherUser = previousState && previousState.userName !== userName;
        
        if (!validation.canParticipate) {
          if (icon) {
            icon.innerHTML = "ðŸš«"; // No puede participar
          }
          
          // Mostrar restricciones solo si es nuevo o cambiÃ³ de usuario
          if (!previousState || wasAnotherUser || !hadPreviousRestrictions) {
            validation.restrictions.forEach(restriction => {
              notify.error(`${fullName}: ${restriction}`);
            });
            
            // Mostrar reglas que aplican
            if (validation.rulesDescription && validation.rulesDescription.length > 0) {
              notify.error(`Condiciones de ${fullName}: ${validation.rulesDescription.join(', ')}`);
            }
          }
          
        } else if (validation.warnings && validation.warnings.length > 0) {
          if (icon) {
            icon.innerHTML = "âš ï¸"; // Advertencia
          }
          
          // Si antes tenÃ­a restricciones y ahora solo advertencias, notificar mejora
          if (hadPreviousRestrictions) {
            notify.open({
              type: 'info',
              message: `${fullName}: âœ“ Ya puede participar (con advertencias)`
            });
          }
          
          // Mostrar advertencias solo si es nuevo o cambiÃ³
          if (!previousState || wasAnotherUser || (!hadPreviousWarnings && !hadPreviousRestrictions)) {
            validation.warnings.forEach(warning => {
              notify.open({
                type: 'warning',
                message: `${fullName}: ${warning}`
              });
            });
          }
          
        } else {
          if (icon) {
            icon.innerHTML = "âœ…"; // Todo bien
          }
          
          // Si antes tenÃ­a restricciones o advertencias y ahora estÃ¡ bien, notificar
          if (previousState && (hadPreviousRestrictions || hadPreviousWarnings)) {
            // Solo notificar si es el mismo usuario
            if (!wasAnotherUser) {
              notify.success(`${fullName}: âœ“ Cumple todas las condiciones`);
            }
          }
        }
        
        // Guardar estado actual
        validationStates.set(stateKey, currentState);

        // AÃ±adir tooltip con informaciÃ³n de reglas
        if (icon && validation.rulesDescription && validation.rulesDescription.length > 0) {
          icon.title = `Condiciones de ${fullName}:\n${validation.rulesDescription.join('\n')}`;
        }
        
      } catch (error) {
        console.error('Error validating participation rules:', error);
        if (icon) {
          icon.innerHTML = ""; // Limpiar icono en caso de error
        }
      }
    } else {
      // Sin reglas de participaciÃ³n
      if (icon) {
        icon.innerHTML = ""; // Limpiar icono si no hay restricciones
      }
      
      // Si antes tenÃ­a restricciones/advertencias y ahora no tiene reglas, notificar
      if (previousState && (previousState.hasRestrictions || previousState.hasWarnings)) {
        const wasAnotherUser = previousState.userName !== userName;
        if (!wasAnotherUser) {
          notify.open({
            type: 'info',
            message: `${fullName}: âœ“ Sin condiciones especiales`
          });
        }
      }
      
      // Guardar estado sin reglas
      validationStates.set(stateKey, {
        userName: userName,
        hasRestrictions: false,
        hasWarnings: false,
        canParticipate: true
      });
    }
  }

  // OPTIMIZACIÃ“N: FunciÃ³n duplicada eliminada - se usa checkUserAssignment para todo

  // OPTIMIZACIÃ“N: VersiÃ³n con debounce de la validaciÃ³n
  const debouncedValidation = debounce(checkUserAssignment, 300);
  
  // Sistema para trackear el estado de validaciÃ³n previo
  const validationStates = new Map(); // key: "day-turno-index", value: { canParticipate: boolean, hasWarnings: boolean, userName: string }

  // ============================================
  // SISTEMA DE UNDO/REDO
  // ============================================

  // Actualizar UI de botones undo/redo
  const updateUndoRedoButtons = () => {
    const undoBtn = document.getElementById('undoBtn') as HTMLButtonElement;
    const redoBtn = document.getElementById('redoBtn') as HTMLButtonElement;
    const stackInfo = undoRedoManager.getStackInfo();

    if (undoBtn) {
      undoBtn.disabled = !stackInfo.canUndo;
      undoBtn.title = undoRedoManager.getUndoDescription() || 'Deshacer (Ctrl+Z)';
    }

    if (redoBtn) {
      redoBtn.disabled = !stackInfo.canRedo;
      redoBtn.title = undoRedoManager.getRedoDescription() || 'Rehacer (Ctrl+Y)';
    }
  };

  // Registrar cambio para undo/redo
  const recordSelectChange = (select: HTMLSelectElement, previousValue: string, newValue: string) => {
    const day = select.dataset.day as WeekDay;
    const turno = select.dataset.turno as Turno;
    const index = parseInt(select.dataset.index || '0');

    const change: ChangeRecord = {
      day,
      turno,
      index,
      previousValue,
      newValue
    };

    undoRedoManager.recordChange(change);
    updateUndoRedoButtons();
  };

  // Aplicar un cambio al DOM (para undo/redo)
  const applyChange = async (change: ChangeRecord) => {
    const select = document.querySelector<HTMLSelectElement>(
      `select.user-select[data-day="${change.day}"][data-turno="${change.turno}"][data-index="${change.index}"]`
    );

    if (select) {
      // Verificar si la opciÃ³n existe
      const optionExists = Array.from(select.options).some(opt => opt.value === change.newValue);

      if (!optionExists && change.newValue) {
        // Crear opciÃ³n si no existe
        const newOption = document.createElement('option');
        newOption.value = change.newValue;
        newOption.textContent = change.newValue;

        const addOption = Array.from(select.options).find(opt => opt.value === 'add');
        if (addOption) {
          select.insertBefore(newOption, addOption);
        } else {
          select.appendChild(newOption);
        }
      }

      select.value = change.newValue;

      // Actualizar visual de precursor
      updatePrecursorBackground(select, change.newValue);

      // Revalidar si hay valor
      if (change.newValue) {
        await checkUserAssignment(select);
      } else {
        // Limpiar icono si se vacÃ­a
        const icon = document.getElementById(`icon-${change.day}-${change.turno}-${change.index}`);
        if (icon) icon.innerHTML = '';
      }

      // Marcar como cambiado
      markAsChanged();
    }
  };

  // Ejecutar Undo
  const performUndo = async () => {
    const changes = undoRedoManager.undo();
    if (changes) {
      for (const change of changes) {
        await applyChange(change);
      }
      updateUndoRedoButtons();
      notify.info(`Deshecho: ${changes.length} cambio(s)`);
    }
  };

  // Ejecutar Redo
  const performRedo = async () => {
    const changes = undoRedoManager.redo();
    if (changes) {
      for (const change of changes) {
        await applyChange(change);
      }
      updateUndoRedoButtons();
      notify.info(`Rehecho: ${changes.length} cambio(s)`);
    }
  };

  // Escuchar cambios en el stack
  undoRedoManager.on('stack-changed', updateUndoRedoButtons);

  // ============================================
  // SISTEMA DE VISTA DE CONFLICTOS GLOBAL
  // ============================================

  interface ConflictInfo {
    type: 'duplicate' | 'restriction' | 'warning';
    userName: string;
    fullName: string;
    locations: Array<{ day: string; turno: string; index: number }>;
    message: string;
  }

  // Analizar todos los conflictos de la semana
  const analyzeWeekConflicts = async (): Promise<ConflictInfo[]> => {
    const conflicts: ConflictInfo[] = [];
    const userAssignments = new Map<string, Array<{ day: string; turno: string; index: number; select: HTMLSelectElement }>>();

    // Recopilar todas las asignaciones
    document.querySelectorAll<HTMLSelectElement>('select.user-select').forEach(select => {
      const userName = select.value;
      if (userName && userName !== '' && userName !== '--separator--' && userName !== '--error--' && userName !== 'add') {
        const day = select.dataset.day || '';
        const turno = select.dataset.turno || '';
        const index = parseInt(select.dataset.index || '0');

        if (!userAssignments.has(userName)) {
          userAssignments.set(userName, []);
        }
        userAssignments.get(userName)!.push({ day, turno, index, select });
      }
    });

    // Detectar usuarios duplicados
    for (const [userName, locations] of userAssignments) {
      if (locations.length > 1) {
        const fullName = await getUserFullName(userName);
        const locationStrings = locations.map(l => `${l.day} ${l.turno}`);

        conflicts.push({
          type: 'duplicate',
          userName,
          fullName,
          locations: locations.map(l => ({ day: l.day, turno: l.turno, index: l.index })),
          message: `${fullName} estÃ¡ asignado ${locations.length} veces: ${locationStrings.join(', ')}`
        });
      }
    }

    // Detectar restricciones de participaciÃ³n
    for (const [stateKey, state] of validationStates) {
      if (state.hasRestrictions || state.hasWarnings) {
        const [day, turno, indexStr] = stateKey.split('-');
        const fullName = await getUserFullName(state.userName);

        // Evitar duplicados si ya estÃ¡ en conflictos por duplicaciÃ³n
        const alreadyInConflicts = conflicts.some(c =>
          c.userName === state.userName && c.type === 'duplicate'
        );

        if (!alreadyInConflicts) {
          conflicts.push({
            type: state.hasRestrictions ? 'restriction' : 'warning',
            userName: state.userName,
            fullName,
            locations: [{ day, turno, index: parseInt(indexStr) }],
            message: state.hasRestrictions
              ? `${fullName} tiene restricciones de participaciÃ³n en ${day} ${turno}`
              : `${fullName} tiene advertencias en ${day} ${turno}`
          });
        }
      }
    }

    return conflicts;
  };

  // Renderizar lista de conflictos
  const renderConflicts = (conflicts: ConflictInfo[]) => {
    const container = document.getElementById('conflictsList');
    const countBadge = document.getElementById('conflictsCount');
    const floatingBadge = document.getElementById('floatingConflictsBadge');

    if (!container) return;

    // Actualizar badges
    if (countBadge) countBadge.textContent = String(conflicts.length);
    if (floatingBadge) {
      if (conflicts.length > 0) {
        floatingBadge.textContent = String(conflicts.length);
        floatingBadge.classList.remove('hidden');
      } else {
        floatingBadge.classList.add('hidden');
      }
    }

    if (conflicts.length === 0) {
      container.innerHTML = `
        <div class="text-center text-gray-500 py-8">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-3 text-green-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <p class="font-medium text-green-600">Â¡Sin conflictos!</p>
          <p class="text-sm">Todas las asignaciones son vÃ¡lidas</p>
        </div>
      `;
      return;
    }

    const getIconForType = (type: string) => {
      switch (type) {
        case 'duplicate': return 'ðŸ‘¥';
        case 'restriction': return 'ðŸš«';
        case 'warning': return 'âš ï¸';
        default: return 'â“';
      }
    };

    const getColorForType = (type: string) => {
      switch (type) {
        case 'duplicate': return 'bg-orange-50 border-orange-200 text-orange-800';
        case 'restriction': return 'bg-red-50 border-red-200 text-red-800';
        case 'warning': return 'bg-yellow-50 border-yellow-200 text-yellow-800';
        default: return 'bg-gray-50 border-gray-200 text-gray-800';
      }
    };

    container.innerHTML = conflicts.map(conflict => `
      <div class="mb-3 p-3 border rounded-lg ${getColorForType(conflict.type)}">
        <div class="flex items-start space-x-2">
          <span class="text-lg">${getIconForType(conflict.type)}</span>
          <div class="flex-1">
            <p class="text-sm font-medium">${conflict.message}</p>
            <div class="flex flex-wrap gap-1 mt-2">
              ${conflict.locations.map(loc => `
                <button
                  class="text-xs px-2 py-1 bg-white border rounded hover:bg-gray-100 transition-colors conflict-location-btn"
                  data-day="${loc.day}"
                  data-turno="${loc.turno}"
                  data-index="${loc.index}"
                >
                  ðŸ“ ${loc.day} ${loc.turno}
                </button>
              `).join('')}
            </div>
          </div>
        </div>
      </div>
    `).join('');

    // Agregar event listeners para navegar a la ubicaciÃ³n
    container.querySelectorAll('.conflict-location-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const day = (btn as HTMLElement).dataset.day;
        const turno = (btn as HTMLElement).dataset.turno;
        const index = (btn as HTMLElement).dataset.index;

        // Encontrar y resaltar el select correspondiente
        const select = document.querySelector<HTMLSelectElement>(
          `select.user-select[data-day="${day}"][data-turno="${turno}"][data-index="${index}"]`
        );

        if (select) {
          // Scroll hacia el select
          select.scrollIntoView({ behavior: 'smooth', block: 'center' });

          // Resaltar temporalmente
          select.classList.add('ring-4', 'ring-red-500', 'ring-opacity-50');
          setTimeout(() => {
            select.classList.remove('ring-4', 'ring-red-500', 'ring-opacity-50');
          }, 2000);

          // Cerrar el panel
          document.getElementById('conflictsPanel')?.classList.add('hidden');
        }
      });
    });
  };

  // Actualizar conflictos
  const refreshConflicts = async () => {
    const conflicts = await analyzeWeekConflicts();
    renderConflicts(conflicts);
  };

  // ============================================
  // BÃšSQUEDA EN VISTA PRINCIPAL
  // ============================================

  // FunciÃ³n para buscar y resaltar usuarios en el programa
  const searchInProgram = (searchTerm: string) => {
    const selects = document.querySelectorAll<HTMLSelectElement>('select.user-select');
    const searchInput = document.getElementById('programSearchInput') as HTMLInputElement;
    const clearBtn = document.getElementById('clearSearchBtn');
    const resultsInfo = document.getElementById('searchResultsInfo');

    // Limpiar resaltados anteriores
    selects.forEach(select => {
      select.classList.remove('ring-4', 'ring-yellow-400', 'ring-opacity-75', 'bg-yellow-50');
      const container = select.closest('.flex');
      if (container) {
        container.classList.remove('bg-yellow-100');
      }
    });

    // Si no hay tÃ©rmino de bÃºsqueda, ocultar botÃ³n y info
    if (!searchTerm.trim()) {
      if (clearBtn) clearBtn.classList.add('hidden');
      if (resultsInfo) resultsInfo.classList.add('hidden');
      return;
    }

    // Mostrar botÃ³n de limpiar
    if (clearBtn) clearBtn.classList.remove('hidden');

    const normalizedSearch = searchTerm.toLowerCase().trim();
    let matchCount = 0;
    const matchedLocations: string[] = [];

    // Buscar coincidencias
    selects.forEach(select => {
      const selectedOption = select.options[select.selectedIndex];
      if (selectedOption && selectedOption.value && selectedOption.value !== '--separator--' && selectedOption.value !== 'add') {
        const displayText = selectedOption.textContent?.toLowerCase() || '';
        const userName = selectedOption.value.toLowerCase();

        if (displayText.includes(normalizedSearch) || userName.includes(normalizedSearch)) {
          // Resaltar coincidencia
          select.classList.add('ring-4', 'ring-yellow-400', 'ring-opacity-75', 'bg-yellow-50');
          const container = select.closest('.flex');
          if (container) {
            container.classList.add('bg-yellow-100');
          }

          matchCount++;
          const day = select.dataset.day || '';
          const turno = select.dataset.turno || '';
          matchedLocations.push(`${day} ${turno}`);
        }
      }
    });

    // Mostrar informaciÃ³n de resultados
    if (resultsInfo) {
      if (matchCount > 0) {
        resultsInfo.textContent = `${matchCount} coincidencia${matchCount > 1 ? 's' : ''} encontrada${matchCount > 1 ? 's' : ''}`;
        resultsInfo.classList.remove('hidden');
        resultsInfo.classList.remove('text-gray-500');
        resultsInfo.classList.add('text-green-600');
      } else {
        resultsInfo.textContent = 'Sin coincidencias';
        resultsInfo.classList.remove('hidden');
        resultsInfo.classList.remove('text-green-600');
        resultsInfo.classList.add('text-gray-500');
      }
    }

    // Si hay exactamente una coincidencia, hacer scroll hacia ella
    if (matchCount === 1) {
      const matchedSelect = document.querySelector<HTMLSelectElement>('select.user-select.ring-yellow-400');
      if (matchedSelect) {
        matchedSelect.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
  };

  // Limpiar bÃºsqueda
  const clearSearch = () => {
    const searchInput = document.getElementById('programSearchInput') as HTMLInputElement;
    if (searchInput) {
      searchInput.value = '';
      searchInProgram('');
    }
  };

  // ============================================
  // VALIDACIÃ“N DE CAPITÃN POR TURNO
  // ============================================

  interface TurnoCapitanStatus {
    day: string;
    turno: string;
    hasCapitan: boolean;
    capitanName?: string;
    assignedUsers: string[];
  }

  // Verificar si un usuario es capitÃ¡n basÃ¡ndose en el texto de display
  const isUserCapitan = (displayText: string): boolean => {
    return displayText.includes('[C]') || displayText.toLowerCase().includes('capitan');
  };

  // Analizar estado de capitanes por turno
  const analyzeCapitanStatus = async (): Promise<TurnoCapitanStatus[]> => {
    const turnoStatuses: TurnoCapitanStatus[] = [];
    const turnoMap = new Map<string, TurnoCapitanStatus>();

    // Agrupar selects por dÃ­a-turno
    document.querySelectorAll<HTMLSelectElement>('select.user-select').forEach(select => {
      const day = select.dataset.day || '';
      const turno = select.dataset.turno || '';
      const key = `${day}-${turno}`;

      if (!turnoMap.has(key)) {
        turnoMap.set(key, {
          day,
          turno,
          hasCapitan: false,
          assignedUsers: []
        });
      }

      const status = turnoMap.get(key)!;
      const selectedOption = select.options[select.selectedIndex];

      if (selectedOption && selectedOption.value &&
          selectedOption.value !== '--separator--' &&
          selectedOption.value !== 'add' &&
          selectedOption.value !== '') {
        const displayText = selectedOption.textContent || '';
        status.assignedUsers.push(displayText);

        if (isUserCapitan(displayText)) {
          status.hasCapitan = true;
          status.capitanName = displayText.replace('[C]', '').trim();
        }
      }
    });

    // Convertir a array y filtrar solo turnos con asignaciones pero sin capitÃ¡n
    for (const [key, status] of turnoMap) {
      if (status.assignedUsers.length > 0) {
        turnoStatuses.push(status);
      }
    }

    return turnoStatuses;
  };

  // Verificar capitanes y mostrar advertencias
  const validateCapitanes = async () => {
    const statuses = await analyzeCapitanStatus();
    const turnosSinCapitan = statuses.filter(s => !s.hasCapitan && s.assignedUsers.length > 0);

    if (turnosSinCapitan.length === 0) {
      notify.success('Todos los turnos con asignaciones tienen capitÃ¡n');
      return true;
    }

    // Mostrar advertencias para turnos sin capitÃ¡n
    turnosSinCapitan.forEach(status => {
      notify.warning(`âš ï¸ ${status.day} ${status.turno}: Sin capitÃ¡n asignado (${status.assignedUsers.length} usuarios)`);
    });

    return false;
  };

  // Agregar indicador visual de capitÃ¡n en turnos
  const updateCapitanIndicators = async () => {
    const statuses = await analyzeCapitanStatus();

    // Buscar contenedores de turno y agregar/actualizar indicador
    statuses.forEach(status => {
      // Buscar el primer select del turno para encontrar el contenedor
      const firstSelect = document.querySelector<HTMLSelectElement>(
        `select.user-select[data-day="${status.day}"][data-turno="${status.turno}"][data-index="0"]`
      );

      if (firstSelect) {
        const container = firstSelect.closest('.turno-container, .flex-col, [data-turno]')?.parentElement;
        if (container) {
          // Buscar o crear indicador
          let indicator = container.querySelector('.capitan-indicator');
          if (!indicator) {
            indicator = document.createElement('span');
            indicator.className = 'capitan-indicator text-xs px-2 py-1 rounded-full ml-2';
            // Insertar despuÃ©s del tÃ­tulo del turno si existe
            const turnoTitle = container.querySelector('h4, .turno-title, span');
            if (turnoTitle) {
              turnoTitle.appendChild(indicator);
            }
          }

          if (status.hasCapitan) {
            indicator.textContent = 'ðŸ‘® CapitÃ¡n';
            indicator.classList.remove('bg-yellow-100', 'text-yellow-800');
            indicator.classList.add('bg-green-100', 'text-green-800');
          } else if (status.assignedUsers.length > 0) {
            indicator.textContent = 'âš ï¸ Sin capitÃ¡n';
            indicator.classList.remove('bg-green-100', 'text-green-800');
            indicator.classList.add('bg-yellow-100', 'text-yellow-800');
          } else {
            indicator.textContent = '';
          }
        }
      }
    });
  };

  // ============================================
  // COPIAR SEMANA ANTERIOR
  // ============================================

  // Obtener datos de la semana anterior
  const getPreviousWeekData = async (): Promise<Record<string, string>> => {
    const previousWeekStart = new Date(currentDate);
    previousWeekStart.setDate(previousWeekStart.getDate() - previousWeekStart.getDay() + 1 - 7); // Ir a la semana anterior

    try {
      const response = await fetch(
        `/api/getWeekData.json?date=${previousWeekStart.toISOString().split('T')[0]}`
      );
      if (response.ok) {
        return await response.json();
      }
    } catch (error) {
      console.error('Error fetching previous week data:', error);
    }
    return {};
  };

  // Copiar asignaciones de la semana anterior
  const copyFromPreviousWeek = async () => {
    const previousWeekData = await getPreviousWeekData();

    if (Object.keys(previousWeekData).length === 0) {
      notify.warning('No hay datos de la semana anterior para copiar');
      return;
    }

    // Guardar estado actual para undo
    const bulkChanges: ChangeRecord[] = [];
    let copiedCount = 0;
    let skippedCount = 0;

    // Aplicar datos de la semana anterior
    for (const [key, userName] of Object.entries(previousWeekData)) {
      const [day, turno, indexStr] = key.split('-');
      const index = parseInt(indexStr);

      const select = document.querySelector<HTMLSelectElement>(
        `select.user-select[data-day="${day}"][data-turno="${turno}"][data-index="${index}"]`
      );

      if (select) {
        const previousValue = select.value;

        // Verificar si la opciÃ³n existe
        let optionExists = Array.from(select.options).some(opt => opt.value === userName);

        if (!optionExists && userName) {
          // Crear opciÃ³n si no existe
          const newOption = document.createElement('option');
          newOption.value = userName;
          newOption.textContent = `${userName} (copiado)`;
          newOption.style.fontStyle = 'italic';

          const addOption = Array.from(select.options).find(opt => opt.value === 'add');
          if (addOption) {
            select.insertBefore(newOption, addOption);
          } else {
            select.appendChild(newOption);
          }
          optionExists = true;
        }

        if (optionExists) {
          // Registrar cambio para undo
          if (previousValue !== userName) {
            bulkChanges.push({
              day: day as WeekDay,
              turno: turno as Turno,
              index,
              previousValue,
              newValue: userName
            });

            select.value = userName;
            updatePrecursorBackground(select, userName);
            copiedCount++;
          }
        } else {
          skippedCount++;
        }
      }
    }

    // Registrar todos los cambios como una operaciÃ³n de bulk
    if (bulkChanges.length > 0) {
      undoRedoManager.recordChange(bulkChanges, 'bulk');
      updateUndoRedoButtons();
      markAsChanged();
    }

    // Mostrar resultado
    if (copiedCount > 0) {
      notify.success(`Se copiaron ${copiedCount} asignaciones de la semana anterior`);

      // Validar asignaciones copiadas
      document.querySelectorAll<HTMLSelectElement>('select.user-select').forEach(async (select) => {
        if (select.value && select.value !== '--separator--' && select.value !== 'add') {
          await checkUserAssignment(select);
        }
      });

      // Actualizar panel de conflictos si estÃ¡ visible
      const conflictsPanel = document.getElementById('conflictsPanel');
      if (conflictsPanel && !conflictsPanel.classList.contains('hidden')) {
        await refreshConflicts();
      }
    }

    if (skippedCount > 0) {
      notify.info(`${skippedCount} asignaciones no se pudieron copiar (usuarios no disponibles)`);
    }
  };

  // Configurar event listeners para botones y teclado
  document.addEventListener('DOMContentLoaded', () => {
    // Botones de undo/redo
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');

    if (undoBtn) {
      undoBtn.addEventListener('click', performUndo);
    }

    if (redoBtn) {
      redoBtn.addEventListener('click', performRedo);
    }

    // Atajos de teclado
    document.addEventListener('keydown', async (event) => {
      // Ctrl+Z para deshacer
      if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
        event.preventDefault();
        await performUndo();
      }

      // Ctrl+Y o Ctrl+Shift+Z para rehacer
      if ((event.ctrlKey || event.metaKey) && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
        event.preventDefault();
        await performRedo();
      }
    });

    // Limpiar undo/redo stack cuando cambia la semana
    const originalClearUsersCache = window.clearUsersCache;
    window.clearUsersCache = () => {
      originalClearUsersCache();
      undoRedoManager.clear();
      updateUndoRedoButtons();
    };

    // BotÃ³n copiar semana anterior
    const copyPreviousWeekBtn = document.getElementById('copyPreviousWeekBtn');
    if (copyPreviousWeekBtn) {
      copyPreviousWeekBtn.addEventListener('click', async () => {
        if (confirm('Â¿Desea copiar las asignaciones de la semana anterior?\n\nEsto reemplazarÃ¡ las asignaciones actuales.')) {
          spinnerOverlay?.classList.add('active');
          try {
            await copyFromPreviousWeek();
          } finally {
            spinnerOverlay?.classList.remove('active');
          }
        }
      });
    }

    // BotÃ³n validar capitanes
    const validateCapitanesBtn = document.getElementById('validateCapitanesBtn');
    if (validateCapitanesBtn) {
      validateCapitanesBtn.addEventListener('click', async () => {
        spinnerOverlay?.classList.add('active');
        try {
          await validateCapitanes();
          await updateCapitanIndicators();
        } finally {
          spinnerOverlay?.classList.remove('active');
        }
      });
    }

    // BÃºsqueda en vista principal
    const programSearchInput = document.getElementById('programSearchInput') as HTMLInputElement;
    const clearSearchBtn = document.getElementById('clearSearchBtn');

    if (programSearchInput) {
      // Debounce para la bÃºsqueda
      let searchTimeout: ReturnType<typeof setTimeout>;
      programSearchInput.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          searchInProgram(programSearchInput.value);
        }, 300);
      });

      // Atajo de teclado: Escape para limpiar
      programSearchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          clearSearch();
          programSearchInput.blur();
        }
      });
    }

    if (clearSearchBtn) {
      clearSearchBtn.addEventListener('click', clearSearch);
    }

    // Atajo global: Ctrl+F para enfocar bÃºsqueda
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        // Solo prevenir si no estÃ¡ en un input
        const activeElement = document.activeElement;
        if (activeElement?.tagName !== 'INPUT' && activeElement?.tagName !== 'TEXTAREA') {
          e.preventDefault();
          programSearchInput?.focus();
        }
      }
    });

    // Panel de conflictos
    const conflictsPanel = document.getElementById('conflictsPanel');
    const conflictsToggle = document.getElementById('conflictsToggle');
    const closeConflictsBtn = document.getElementById('closeConflictsBtn');
    const refreshConflictsBtn = document.getElementById('refreshConflictsBtn');

    if (conflictsToggle) {
      conflictsToggle.addEventListener('click', async () => {
        conflictsPanel?.classList.toggle('hidden');
        if (!conflictsPanel?.classList.contains('hidden')) {
          await refreshConflicts();
        }
      });
    }

    if (closeConflictsBtn) {
      closeConflictsBtn.addEventListener('click', () => {
        conflictsPanel?.classList.add('hidden');
      });
    }

    if (refreshConflictsBtn) {
      refreshConflictsBtn.addEventListener('click', async () => {
        await refreshConflicts();
        notify.info('AnÃ¡lisis de conflictos actualizado');
      });
    }

    // Cerrar panel al hacer clic fuera
    document.addEventListener('click', (event) => {
      const target = event.target as Node;
      if (conflictsPanel && conflictsToggle &&
          !conflictsPanel.contains(target) && !conflictsToggle.contains(target)) {
        conflictsPanel.classList.add('hidden');
      }
    });
  });

  // Event listener movido al DOMContentLoaded

  // OPTIMIZACIÃ“N: fetchWeekData consolidado con loadWeekData - usar loadWeekData para todo

  // FunciÃ³n helper para mostrar popup de advertencia
  const showWarningPopup = (message: string) => {
    const warningPopup = document.getElementById("warningPopup");
    const warningMessage = document.getElementById("warningMessage");
    if (warningMessage) warningMessage.textContent = message;
    if (warningPopup) warningPopup.classList.remove("hidden");
  };

  // Variables globales
  let initialSelectValues = {};

  async function showConfirmationModal() {
    return new Promise((resolve) => {
      const confirmationModal = document.getElementById("confirmationModal");
      const cancelBtn = document.getElementById("cancelBtn");
      const saveBtnModal = document.getElementById("saveBtnModal");
      
      if (confirmationModal) confirmationModal.classList.remove("hidden");
      
      if (cancelBtn) {
        cancelBtn.onclick = () => {
          if (confirmationModal) confirmationModal.classList.add("hidden");
          resolve(false);
        };
      }
      
      if (saveBtnModal) {
        saveBtnModal.onclick = async () => {
          if (confirmationModal) confirmationModal.classList.add("hidden");
          await saveWeekData();
          resolve(true);
        };
      }
    });
  }

  function hasChanges() {
    let changes = false;
    document.querySelectorAll<HTMLSelectElement>("select.user-select").forEach((select) => {
      const key = `${select.dataset.day}-${select.dataset.turno}-${select.dataset.index}`;
      if (initialSelectValues[key] !== select.value) {
        changes = true;
      }
    });
    return changes;
  }

  function setInitialSelectValues() {
    setTimeout(() => {
      document.querySelectorAll<HTMLSelectElement>("select.user-select").forEach((select) => {
        const key = `${select.dataset.day}-${select.dataset.turno}-${select.dataset.index}`;
        initialSelectValues[key] = select.value;
      });
    }, 1000);
  }
  
  // OPTIMIZACIÃ“N: CÃ³digo movido al DOMContentLoaded principal arriba
</script>

<style>
  .spinner {
    border: 4px solid rgba(0, 0, 0, 0.1);
    border-left-color: #0fa6fd;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  .spinner-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.8);
    justify-content: center;
    align-items: center;
    z-index: 9999; /* Ensure the spinner is on top of other elements */
  }

  .spinner-overlay.active {
    display: flex;
  }

  /* Estilos para precursores */
  .precursor-select {
    background-color: #dcfce7 !important; /* bg-green-100 */
    border-color: #16a34a !important; /* border-green-600 */
  }

  .precursor-container {
    background-color: #f0fdf4; /* bg-green-50 */
    border-radius: 0.375rem; /* rounded-md */
    padding: 0.25rem; /* p-1 */
    border: 1px solid #bbf7d0; /* border-green-200 */
  }
</style>
