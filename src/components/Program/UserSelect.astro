---
// Componente para selector de usuarios con validaci√≥n
import type { WeekDay, Turno } from '../../types/program';

interface Props {
  day: WeekDay;
  turno: Turno;
  index: number;
  date: string;
  value?: string;
  disabled?: boolean;
  class?: string;
}

const { day, turno, index, date, value = "", disabled = false, class: className = "" } = Astro.props;
const selectId = `select-${day}-${turno}-${index}`;
const iconId = `icon-${day}-${turno}-${index}`;
---

<div class="inline-block mr-2">
  <select
    id={selectId}
    class={`border border-gray-300 focus:border-cyan-700 bg-white rounded-md w-64 px-1 py-2 my-1 user-select ${className}`}
    data-day={day}
    data-turno={turno}
    data-index={index}
    data-date={date}
    value={value}
    disabled={disabled}
  >
    <option value=""></option>
    <option value="--separator--" disabled>Seleccionar usuario...</option>
    <!-- Las opciones de usuarios se cargar√°n din√°micamente -->
  </select>
  <span
    class="icon ml-1"
    id={iconId}
    title="Estado de validaci√≥n"
  />
</div>

<script>
  import type { UserData, WeekDay, Turno } from '../../types/program';
  import { UserLoader } from '../../utils/program/userLoader';
  import { ValidationManager } from '../../utils/program/validationManager';
  import { programStore } from '../../stores/programStore';

  class UserSelectComponent {
    private element: HTMLSelectElement;
    private iconElement: HTMLSpanElement;
    private day: WeekDay;
    private turno: Turno;
    private index: number;
    private date: Date;

    constructor(selectElement: HTMLSelectElement) {
      console.log('üöÄ UserSelectComponent: Inicializando componente');
      this.element = selectElement;
      this.day = selectElement.dataset.day as WeekDay;
      this.turno = selectElement.dataset.turno as Turno;
      this.index = parseInt(selectElement.dataset.index || '0');
      this.date = new Date(selectElement.dataset.date || '');

      console.log('üöÄ UserSelectComponent: d√≠a=', this.day, 'turno=', this.turno, 'index=', this.index, 'date=', this.date);

      const iconId = `icon-${this.day}-${this.turno}-${this.index}`;
      this.iconElement = document.getElementById(iconId) as HTMLSpanElement;

      this.init();
    }

    private async init() {
      await this.loadUsers();
      this.attachEventListeners();
      
      // Cargar valor inicial si existe
      const savedValue = programStore.getAssignment(this.day, this.turno, this.index);
      if (savedValue) {
        this.element.value = savedValue;
        this.updatePrecursorBackground(savedValue);
        await this.validateCurrentSelection();
      }
    }

    private async loadUsers() {
      try {
        const users = await UserLoader.loadUsersForSelect(this.day, this.turno);
        this.populateOptions(users);
      } catch (error) {
        console.error('Error loading users for select:', error);
        this.showError('Error cargando usuarios');
      }
    }

    private populateOptions(users: UserData[]) {
      // Limpiar opciones existentes (excepto las por defecto)
      const defaultOptions = Array.from(this.element.options).slice(0, 2);
      this.element.innerHTML = '';
      
      // Agregar opciones por defecto
      defaultOptions.forEach(option => this.element.appendChild(option));

      // Agregar usuarios
      users.forEach(user => {
        if (!user.nombre || !user.userName) {
          console.warn('Usuario sin nombre o userName:', user);
          return;
        }

        const option = document.createElement('option');
        option.value = user.userName;
        
        // Formatear texto de display
        let displayText = UserLoader.formatUserForDisplay(user);
        const statusIcon = UserLoader.getStatusIcon(user);
        option.textContent = `${displayText} ${statusIcon}`;
        
        // Agregar datos adicionales (incluyendo congregaci√≥n completa para validaci√≥n de reuniones)
        option.dataset.congregacionId = user.congregacion?.id?.toString() || '';
        option.dataset.congregacionNombre = user.congregacion?.nombre || '';
        option.dataset.congregacionDiaReunion = user.congregacion?.diaReunion || '';
        option.dataset.congregacionTurnoReunion = user.congregacion?.turnoReunion || '';
        option.dataset.participationRules = JSON.stringify(user.participation_rules || []);
        option.disabled = user.canParticipate === false;
        
        this.element.appendChild(option);
      });

      // Agregar opci√≥n "A√±adir usuario"
      const addOption = document.createElement('option');
      addOption.value = 'add';
      addOption.textContent = 'A√±adir usuario';
      this.element.appendChild(addOption);
    }

    private attachEventListeners() {
      this.element.addEventListener('change', this.handleChange.bind(this));
    }

    private async handleChange(event: Event) {
      const target = event.target as HTMLSelectElement;
      const selectedValue = target.value;

      if (selectedValue === 'add') {
        this.showUserModal();
        return;
      }

      if (selectedValue === '') {
        this.clearAssignment();
        return;
      }

      await this.handleUserSelection(selectedValue);
    }

    private async handleUserSelection(userName: string) {
      // Actualizar store
      const assignment = {
        day: this.day,
        turno: this.turno,
        index: this.index,
        userName,
        date: this.date.toISOString().split('T')[0]
      };
      
      programStore.assignUser(assignment);

      // Verificar si el usuario es precursor y mostrar fondo verde
      this.updatePrecursorBackground(userName);

      // Validar inmediatamente
      await this.validateCurrentSelection();
    }

    private clearAssignment() {
      programStore.removeUser(this.day, this.turno, this.index);
      this.clearValidationIcon();
      this.updatePrecursorBackground("");
      
      // Notificar si hab√≠a restricciones previas
      const previousState = programStore.getValidationState(this.day, this.turno, this.index);
      if (previousState && (previousState.hasRestrictions || previousState.hasWarnings)) {
        const message = `${this.day} ${this.turno} posici√≥n ${this.index + 1}: Sin restricciones (vac√≠o)`;
        programStore.addNotification('info', message);
        // Tambi√©n mostrar con Notyf
        if ((window as any).notify) {
          (window as any).notify.info(message);
        }
      }
    }

    private async showUserConditionsInfo(userName: string, user: any) {
      const fullName = await programStore.getUserFullName(userName);
      const notify = (window as any).notify;
      
      console.log('üîç DEBUG - showUserConditionsInfo iniciando para:', userName);
      
      // Intentar obtener las reglas de participaci√≥n 
      let participationRules = null;
      
      // PRIMERO: Intentar desde el data attribute del select (m√°s confiable)
      const selectedOption = this.element.options[this.element.selectedIndex];
      console.log('üîç DEBUG - selectedOption:', selectedOption);
      
      if (selectedOption && selectedOption.dataset.participationRules) {
        try {
          participationRules = JSON.parse(selectedOption.dataset.participationRules);
          console.log('üîç DEBUG - Reglas obtenidas desde DOM:', participationRules);
        } catch (error) {
          console.error('Error parsing participation rules from DOM:', error);
        }
      }
      
      // SEGUNDO: Si no hay en DOM, intentar desde el store
      if (!participationRules || participationRules.length === 0) {
        if (user && user.participation_rules) {
          participationRules = user.participation_rules;
          console.log('üîç DEBUG - Reglas obtenidas desde store:', participationRules);
        }
      }
      
      if (!participationRules || participationRules.length === 0) {
        console.log('üîç DEBUG - No se encontraron reglas de participaci√≥n para', userName);
        return;
      }
      
      console.log('üîç DEBUG - Procesando', participationRules.length, 'reglas para', userName);
      
      // Generar descripci√≥n de las condiciones configuradas
      const conditionsDescriptions: string[] = [];
      
      participationRules.forEach((rule: any) => {
        console.log('üîç DEBUG - Procesando regla:', rule);
        switch (rule.type) {
          case 'max_per_month':
            conditionsDescriptions.push(`M√°ximo ${rule.value} ${rule.value === 1 ? 'vez' : 'veces'} al mes`);
            break;
          case 'max_per_week':
            conditionsDescriptions.push(`M√°ximo ${rule.value} ${rule.value === 1 ? 'vez' : 'veces'} por semana`);
            break;
          case 'specific_weeks':
            const weeks = Array.isArray(rule.value) ? rule.value : [rule.value];
            conditionsDescriptions.push(`Solo puede participar en las semanas: ${weeks.join(', ')}`);
            break;
          case 'alternating_weeks':
            conditionsDescriptions.push(`Participa en semanas alternadas (una s√≠, una no)`);
            break;
          case 'weekly_availability':
            conditionsDescriptions.push(`Env√≠a su disponibilidad semanalmente`);
            break;
          default:
            if (rule.description) {
              conditionsDescriptions.push(rule.description);
            }
            break;
        }
      });
      
      console.log('üîç DEBUG - Condiciones generadas:', conditionsDescriptions);
      
      if (conditionsDescriptions.length > 0) {
        const conditionsMessage = `üîç Condiciones de ${fullName}: ${conditionsDescriptions.join(' ‚Ä¢ ')}`;
        
        console.log('üîç DEBUG - Enviando notificaci√≥n:', conditionsMessage);
        
        // Mostrar con Notyf como notificaci√≥n informativa
        if (notify) {
          notify.open({
            type: 'info',
            message: conditionsMessage,
            duration: 8000  // Duraci√≥n m√°s larga para leer las condiciones
          });
        } else {
          console.log('üîç DEBUG - notify no est√° disponible');
        }
        
        // Tambi√©n agregar al panel de notificaciones
        programStore.addNotification('info', conditionsMessage);
        console.log('üîç DEBUG - Notificaci√≥n enviada al store');
      } else {
        console.log('üîç DEBUG - No se generaron descripciones de condiciones');
      }
    }

    private async validateCurrentSelection() {
      const userName = this.element.value;
      console.log('üîç validateCurrentSelection: Iniciando validaci√≥n para', userName);

      if (!userName || userName === '--separator--' || userName === 'add') {
        console.log('üîç validateCurrentSelection: userName vac√≠o o inv√°lido, saliendo');
        return;
      }

      // Mostrar icono de carga
      this.iconElement.innerHTML = "‚è≥";

      try {
        // PRIMERO: Mostrar las condiciones del usuario si las tiene
        const user = programStore.getUser(userName);
        console.log('üîç DEBUG - User from store:', user);
        
        // Verificar si tiene reglas desde el store O desde el DOM
        let hasRules = user && user.participation_rules && user.participation_rules.length > 0;
        
        if (!hasRules) {
          // Verificar desde el data attribute del select
          const selectedOption = this.element.options[this.element.selectedIndex];
          if (selectedOption && selectedOption.dataset.participationRules) {
            try {
              const rulesFromDOM = JSON.parse(selectedOption.dataset.participationRules);
              hasRules = rulesFromDOM && rulesFromDOM.length > 0;
              console.log('üîç DEBUG - Rules from DOM:', rulesFromDOM, 'hasRules:', hasRules);
            } catch (error) {
              console.error('Error parsing participation rules from DOM:', error);
            }
          }
        }
        
        // Siempre intentar mostrar condiciones si las encontramos
        await this.showUserConditionsInfo(userName, user || {});

        // SEGUNDO: Verificar conflictos
        const conflicts = ValidationManager.findAssignmentConflicts(
          userName, 
          programStore.getState().weekData,
          `${this.day}-${this.turno}-${this.index}`
        );

        if (conflicts.length > 0) {
          this.showConflictValidation(userName, conflicts);
          return;
        }

        // TERCERO: Validar usuario (reglas de participaci√≥n, incidencias, conflictos de reuni√≥n)
        // IMPORTANTE: Siempre ejecutar validaci√≥n para detectar incidencias y conflictos de reuni√≥n
        // Crear userForValidation con al menos el userName (necesario para validar incidencias)
        let userForValidation: UserData = user || { userName, nombre: '', id: 0 } as UserData;

        // Obtener datos adicionales del DOM
        const selectedOption = this.element.options[this.element.selectedIndex];
        if (selectedOption) {
          // Obtener reglas de participaci√≥n del DOM si existen
          if (selectedOption.dataset.participationRules) {
            try {
              const rulesFromDOM = JSON.parse(selectedOption.dataset.participationRules);
              if (rulesFromDOM && rulesFromDOM.length > 0) {
                userForValidation = {
                  ...(userForValidation || { userName, nombre: '', id: 0 }),
                  participation_rules: rulesFromDOM
                } as UserData;
              }
            } catch (error) {
              console.error('Error parsing participation rules from DOM:', error);
            }
          }

          // Obtener datos de congregaci√≥n del DOM (incluyendo diaReunion y turnoReunion para validaci√≥n)
          if (selectedOption.dataset.congregacionId) {
            const congregacionData = {
              id: parseInt(selectedOption.dataset.congregacionId),
              nombre: selectedOption.dataset.congregacionNombre || '',
              diaReunion: selectedOption.dataset.congregacionDiaReunion || '',
              turnoReunion: selectedOption.dataset.congregacionTurnoReunion || ''
            };

            console.log('üîç DEBUG - Congregaci√≥n from DOM:', congregacionData);

            userForValidation = {
              ...userForValidation,
              congregacion: congregacionData
            };
          }
        }

        // Siempre ejecutar validaci√≥n para detectar incidencias y conflictos de reuni√≥n
        const validation = await ValidationManager.validateUserAssignment(
          userName, this.day, this.turno, this.index, this.date, userForValidation
        );

        await this.showValidationResult(userName, validation);
      } catch (error) {
        console.error('Error validating user assignment:', error);
        this.iconElement.innerHTML = "";
      }
    }

    private showConflictValidation(userName: string, conflicts: string[]) {
      this.iconElement.innerHTML = "‚ö†Ô∏è";
      
      const fullName = programStore.getUserFullName(userName);
      const message = `${fullName} ya participa esta semana en ${conflicts.join(", ")}.`;
      programStore.addNotification('error', message);
      
      // Tambi√©n mostrar con Notyf
      if ((window as any).notify) {
        (window as any).notify.error(message);
      }

      const validationState = {
        userName,
        hasRestrictions: true,
        hasWarnings: false,
        canParticipate: false
      };
      
      programStore.setValidationState(this.day, this.turno, this.index, validationState);
    }

    private async showValidationResult(userName: string, validation: any) {
      const fullName = await programStore.getUserFullName(userName);
      const previousState = programStore.getValidationState(this.day, this.turno, this.index);
      
      // Actualizar icono
      this.iconElement.innerHTML = ValidationManager.getValidationIcon(validation);
      
      // Crear nuevo estado
      const newState = ValidationManager.createValidationState(userName, validation);
      
      // Determinar qu√© mensajes mostrar
      const shouldShow = ValidationManager.shouldShowValidationMessage(
        previousState,
        newState,
        !previousState || previousState.userName !== userName
      );

      // Mostrar notificaciones apropiadas
      const messages = ValidationManager.formatValidationMessages(validation, fullName);
      const notify = (window as any).notify;
      
      if (shouldShow.showRestrictions) {
        messages.restrictions.forEach(msg => {
          programStore.addNotification('error', msg);
          // Tambi√©n mostrar con Notyf
          if (notify) {
            notify.error(msg);
          }
        });
        if (validation.rulesDescription) {
          const conditionsMsg = `Condiciones de ${fullName}: ${validation.rulesDescription.join(', ')}`;
          programStore.addNotification('error', conditionsMsg);
          if (notify) {
            notify.error(conditionsMsg);
          }
        }
      }
      
      if (shouldShow.showWarnings) {
        messages.warnings.forEach(msg => {
          programStore.addNotification('warning', msg);
          // Tambi√©n mostrar con Notyf
          if (notify) {
            notify.warning(msg);
          }
        });
      }
      
      if (shouldShow.showSuccess) {
        messages.success.forEach(msg => {
          programStore.addNotification('success', msg);
          // Tambi√©n mostrar con Notyf
          if (notify) {
            notify.success(msg);
          }
        });
      }
      
      if (shouldShow.showImprovement) {
        const improvementMsg = `${fullName}: ‚úì Ya puede participar (con advertencias)`;
        programStore.addNotification('info', improvementMsg);
        // Tambi√©n mostrar con Notyf
        if (notify) {
          notify.info(improvementMsg);
        }
      }

      // Actualizar tooltip
      if (validation.rulesDescription && validation.rulesDescription.length > 0) {
        this.iconElement.title = `Condiciones de ${fullName}:\n${validation.rulesDescription.join('\n')}`;
      }

      // Guardar estado
      programStore.setValidationState(this.day, this.turno, this.index, newState);
    }

    private clearValidationIcon() {
      this.iconElement.innerHTML = "";
      this.iconElement.title = "Estado de validaci√≥n";
    }

    private updatePrecursorBackground(userName: string) {
      if (!userName) {
        // Remover estilo de precursor
        this.element.classList.remove('precursor-select');
        const container = this.element.closest('.inline-block');
        if (container) {
          container.classList.remove('precursor-container');
        }
        return;
      }

      // Obtener informaci√≥n del usuario desde la opci√≥n seleccionada
      const selectedOption = this.element.options[this.element.selectedIndex];
      if (!selectedOption) {
        this.element.classList.remove('precursor-select');
        const container = this.element.closest('.inline-block');
        if (container) {
          container.classList.remove('precursor-container');
        }
        return;
      }

      // Verificar si el usuario es precursor revisando el texto de display
      const displayText = selectedOption.textContent || '';
      const isPrecursor = displayText.toLowerCase().includes('precursor') || 
                         displayText.includes('[P]');

      if (isPrecursor) {
        // Aplicar estilo de precursor
        this.element.classList.add('precursor-select');
        const container = this.element.closest('.inline-block');
        if (container) {
          container.classList.add('precursor-container');
        }
      } else {
        // Remover estilo de precursor
        this.element.classList.remove('precursor-select');
        const container = this.element.closest('.inline-block');
        if (container) {
          container.classList.remove('precursor-container');
        }
      }
    }

    private showUserModal() {
      // Implementar modal de selecci√≥n de usuarios
      // Por ahora, revertir la selecci√≥n
      this.element.value = programStore.getAssignment(this.day, this.turno, this.index) || '';
    }

    private showError(message: string) {
      this.element.innerHTML = `
        <option value=""></option>
        <option value="--error--" disabled>${message}</option>
      `;
    }
  }

  // Inicializar componente cuando el DOM est√© listo
  document.addEventListener('DOMContentLoaded', () => {
    const selectElements = document.querySelectorAll('.user-select');
    selectElements.forEach(select => {
      new UserSelectComponent(select as HTMLSelectElement);
    });
  });
</script>

<style>
  .user-select:disabled {
    @apply bg-gray-100 cursor-not-allowed;
  }
  
  .icon {
    @apply inline-block w-6 text-center;
  }

  /* Estilos para precursores */
  .precursor-select {
    background-color: #dcfce7 !important; /* bg-green-100 */
    border-color: #16a34a !important; /* border-green-600 */
  }

  .precursor-container {
    background-color: #f0fdf4; /* bg-green-50 */
    border-radius: 0.375rem; /* rounded-md */
    padding: 0.25rem; /* p-1 */
    border: 1px solid #bbf7d0; /* border-green-200 */
  }
</style>